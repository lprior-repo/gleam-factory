#!/bin/bash
#
# TDD-TCR Loop: Adversarial AI-driven Test-Driven Development with Test && Commit || Revert
#
# Three AI sessions with filesystem-enforced separation:
# - Auditor: writes tests (can't touch src/)
# - Implementer: writes code (can't touch test/) - with TCR enforcement
# - Reviewer: cleans up after completion
#
# TCR Enforcement:
# - After each implementation attempt, if tests pass -> auto-commit
# - If tests fail -> auto-revert implementer's changes
# - No escape: filesystem locks + automatic revert = discipline enforced
#
# Usage: ./tdd-tcr-loop "Feature description or requirements"
#

set -eo pipefail

# Dependency checks
check_dependencies() {
    local missing=()
    command -v claude >/dev/null 2>&1 || missing+=("claude")
    command -v uuidgen >/dev/null 2>&1 || missing+=("uuidgen")
    git rev-parse --git-dir >/dev/null 2>&1 || missing+=("git (not in a repository)")

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Missing dependencies: ${missing[*]}"
        exit 1
    fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Configuration
SRC_DIR="src"
TEST_DIR="test"
MAX_IMPL_ATTEMPTS=3
MAX_ITERATIONS=10
AUTO_MODE=true

# Handle requirements from file or argument
if [ -f "$1" ]; then
    REQUIREMENTS=$(cat "$1")
    REQUIREMENTS_SOURCE="file: $1"
else
    REQUIREMENTS="$1"
    REQUIREMENTS_SOURCE="argument"
fi

# Detect language from project files
detect_language() {
    if [ -f "gleam.toml" ]; then
        echo "gleam"
    elif [ -f "go.mod" ]; then
        echo "go"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
        echo "python"
    else
        echo "unknown"
    fi
}

PROJECT_LANG=$(detect_language)
TEST_CMD="gleam test"
case "$PROJECT_LANG" in
    gleam) TEST_CMD="gleam test" ;;
    go) TEST_CMD="go test ./..." ;;
    rust) TEST_CMD="cargo test" ;;
    python) TEST_CMD="pytest" ;;
esac

# TCR Statistics
TCR_COMMITS=0
TCR_REVERTS=0

#---------------------------------------------------------------------------
# Utility functions
#---------------------------------------------------------------------------

log_phase() {
    echo ""
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo ""
}

log_info() {
    echo -e "${CYAN}→ $1${NC}"
}

log_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

log_error() {
    echo -e "${RED}✗ $1${NC}"
}

log_tcr() {
    echo -e "${MAGENTA}⟳ TCR: $1${NC}"
}

#---------------------------------------------------------------------------
# Lock management
#---------------------------------------------------------------------------

lock_all() {
    log_info "Locking all source and test files..."
    chmod -R a-w "$SRC_DIR/" 2>/dev/null || true
    chmod -R a-w "$TEST_DIR/" 2>/dev/null || true
}

unlock_src() {
    log_info "Unlocking src/ for implementer..."
    chmod -R u+w "$SRC_DIR/"
}

lock_src() {
    log_info "Locking src/..."
    chmod -R a-w "$SRC_DIR/"
}

unlock_tests() {
    log_info "Unlocking test/ for auditor..."
    chmod -R u+w "$TEST_DIR/"
}

lock_tests() {
    log_info "Locking test/..."
    chmod -R a-w "$TEST_DIR/"
}

#---------------------------------------------------------------------------
# Git/TCR operations
#---------------------------------------------------------------------------

# Commit if tests pass (the "C" in TCR)
tcr_commit() {
    local iteration="$1"
    local message="$2"

    log_tcr "Tests PASSED - Committing changes..."
    git add -A
    git commit -m "PASS(tcr-$iteration): $message" --no-verify 2>/dev/null || true
    TCR_COMMITS=$((TCR_COMMITS + 1))
    log_success "TCR Commit #$TCR_COMMITS"
}

# Revert if tests fail (the "R" in TCR)
tcr_revert() {
    local iteration="$1"

    log_tcr "Tests FAILED - Reverting implementation changes..."

    # Only revert src/ changes, keep test/ changes
    git checkout HEAD -- "$SRC_DIR/" 2>/dev/null || true

    # Clean any new untracked files in src/
    git clean -fd "$SRC_DIR/" 2>/dev/null || true

    TCR_REVERTS=$((TCR_REVERTS + 1))
    log_error "TCR Revert #$TCR_REVERTS - Implementation discarded"
}

#---------------------------------------------------------------------------
# Test execution
#---------------------------------------------------------------------------

# Run tests and capture output. Sets LAST_TEST_OUTPUT and returns exit code.
run_tests() {
    log_info "Running tests ($TEST_CMD)..."
    LAST_TEST_OUTPUT=$($TEST_CMD 2>&1) && return 0 || return 1
}

# Run tests silently, just for pass/fail check
run_tests_quiet() {
    $TEST_CMD >/dev/null 2>&1
}

#---------------------------------------------------------------------------
# AI Session management
#---------------------------------------------------------------------------

auditor_prompt() {
    local iteration="$1"
    local last_impl_result="$2"

    cat <<EOF
You are the AUDITOR in a TDD-TCR loop. Your job is to write tests.

PROJECT: $PROJECT_LANG project
TEST COMMAND: $TEST_CMD

REQUIREMENTS:
$REQUIREMENTS

ITERATION: $iteration

YOUR CONSTRAINTS:
- You can ONLY modify files in test/
- You CANNOT modify files in src/ (read-only, filesystem enforced)
- Write ONE focused test at a time
- The test should FAIL initially (red phase of TDD)

YOUR TASK:
1. Read the current src/ code to understand what exists
2. Read the current tests to understand what's covered
3. Write EXACTLY ONE test that:
   - Tests ONE specific behavior or edge case
   - Drives better code design (not just coverage)
   - Forces the implementer to write clean, focused code
   - Follows testing best practices (arrange-act-assert, descriptive names)

TEST DESIGN PRINCIPLES:
- Each test should validate ONE thing
- Test names should describe the behavior being tested
- Tests should be independent and not rely on each other
- Prefer testing behavior over implementation details
- Edge cases matter: empty inputs, boundaries, error conditions

TCR CONTEXT:
The implementer is under TCR discipline - if they fail tests, their code is REVERTED.
Write tests that are:
- Clear enough that the implementer knows exactly what to build
- Focused enough that they can be implemented in one small step
- Strict enough that they catch real bugs

IMPORTANT: Write ONLY ONE test per iteration. If ALL requirements are fully tested and implemented, output EXACTLY:
REQUIREMENTS_COMPLETE
and do not write any new tests.

$(if [ -n "$last_impl_result" ]; then
    echo "LAST IMPLEMENTATION RESULT:"
    echo "$last_impl_result"
    echo ""
    echo "If tests passed, write the next test for uncovered requirements."
    echo "If tests failed and were REVERTED, consider if your test was too ambitious."
fi)

OUTPUT: Only modify test files. Explain what you're testing and why.
EOF
}

implementer_prompt() {
    local test_output="$1"
    local attempt="$2"

    cat <<EOF
You are the IMPLEMENTER in a TDD-TCR loop. Your job is to make tests pass.

PROJECT: $PROJECT_LANG project
TEST COMMAND: $TEST_CMD

⚠️  TCR DISCIPLINE IS ENFORCED ⚠️
- If tests PASS after your changes → your code is COMMITTED automatically
- If tests FAIL after your changes → your code is REVERTED automatically
- There is NO escape. Write code that works or it disappears.

YOUR CONSTRAINTS:
- You can ONLY modify files in src/
- You CANNOT modify files in test/ (read-only, filesystem enforced)
- Write the MINIMUM code to make tests pass
- Follow existing patterns in the codebase

CURRENT TEST OUTPUT:
$test_output

ATTEMPT: $attempt of $MAX_IMPL_ATTEMPTS

YOUR TASK:
1. Read the failing test to understand what's expected
2. Read the current src/ code
3. Write the MINIMUM code to make ONLY this test pass
4. Do NOT over-engineer or add untested features
5. Each function should do ONE thing well

IMPLEMENTATION PRINCIPLES:
- Write only what the test demands - nothing more
- Keep functions small and focused
- Use descriptive names that explain intent
- Handle the specific case the test covers
- Let the next test drive the next piece of functionality

REMEMBER: Your code will be REVERTED if tests fail. Be precise. Be minimal. Be correct.

OUTPUT: Only modify src files. Explain what you implemented and why.
EOF
}

reviewer_prompt() {
    cat <<EOF
You are the REVIEWER. The TDD-TCR loop has completed and all tests pass.

PROJECT: $PROJECT_LANG project
TEST COMMAND: $TEST_CMD

ORIGINAL REQUIREMENTS:
$REQUIREMENTS

TCR STATISTICS:
- Total commits: $TCR_COMMITS
- Total reverts: $TCR_REVERTS

YOUR TASK:
1. Review all code in src/ and test/ that was created/modified
2. Look for:
   - Code duplication that can be refactored
   - Poor naming that should be improved
   - Missing or incorrect documentation
   - Type safety improvements
   - Idiomatic $PROJECT_LANG patterns that should be applied
   - Any obvious bugs or edge cases the tests missed
3. Make improvements while ensuring ALL TESTS STILL PASS
4. Run '$TEST_CMD' after your changes to verify

CONSTRAINTS:
- You may modify both src/ and test/
- All tests MUST still pass after your changes
- Focus on code quality, not adding new features
- Be conservative - only change what clearly needs improvement

OUTPUT: Describe what you reviewed and what changes you made (if any).
EOF
}

#---------------------------------------------------------------------------
# Main TDD-TCR Loop
#---------------------------------------------------------------------------

run_auditor() {
    local iteration="$1"
    local last_result="$2"
    local prompt

    log_phase "AUDITOR PHASE (Iteration $iteration)"

    # Unlock tests, lock src
    lock_src
    unlock_tests

    prompt=$(auditor_prompt "$iteration" "$last_result")

    log_info "Invoking auditor AI (new session)..."
    AUDITOR_SESSION_ID=$(uuidgen)
    auditor_output=$(claude -p \
        --session-id "$AUDITOR_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
        --append-system-prompt "You are the AUDITOR. You may ONLY modify files in test/. Any attempt to modify src/ will fail. Focus on writing ONE failing test. If all requirements are met, output REQUIREMENTS_COMPLETE." \
        "$prompt" 2>&1)

    echo "$auditor_output"

    # Lock tests when done
    lock_tests

    # Check if auditor says we're done
    if echo "$auditor_output" | grep -q "REQUIREMENTS_COMPLETE"; then
        log_success "Auditor reports all requirements are complete!"
        return 1  # Signal completion
    fi

    log_success "Auditor phase complete"
    return 0
}

run_implementer() {
    local test_output="$1"
    local iteration="$2"
    local attempt=1
    local result

    log_phase "IMPLEMENTER PHASE (with TCR)"

    while [ $attempt -le $MAX_IMPL_ATTEMPTS ]; do
        log_info "Implementation attempt $attempt of $MAX_IMPL_ATTEMPTS"

        # Unlock src, lock tests
        lock_tests
        unlock_src

        # Record state before implementation for potential revert
        log_tcr "Recording pre-implementation state..."

        prompt=$(implementer_prompt "$test_output" "$attempt")

        log_info "Invoking implementer AI (new session)..."
        IMPLEMENTER_SESSION_ID=$(uuidgen)
        claude -p \
            --session-id "$IMPLEMENTER_SESSION_ID" \
            --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
            --append-system-prompt "You are the IMPLEMENTER under TCR discipline. You may ONLY modify files in src/. If tests fail, your changes will be REVERTED. Write MINIMUM code to pass the test." \
            "$prompt" 2>&1

        # Lock src when done
        lock_src

        # TCR: Test && Commit || Revert
        log_phase "TCR CHECK"
        log_info "Running tests to determine commit or revert..."

        if run_tests; then
            # Tests pass - COMMIT
            tcr_commit "$iteration" "Implemented for iteration $iteration"
            log_success "Tests pass! Implementation committed."
            return 0
        else
            # Tests fail - REVERT (LAST_TEST_OUTPUT already set by run_tests)
            tcr_revert "$iteration"
            test_output="$LAST_TEST_OUTPUT"
            attempt=$((attempt + 1))

            if [ $attempt -le $MAX_IMPL_ATTEMPTS ]; then
                log_warning "Trying again with fresh implementation..."
            fi
        fi
    done

    log_error "Implementer failed after $MAX_IMPL_ATTEMPTS attempts (all reverted)"
    return 1
}

run_reviewer() {
    log_phase "REVIEWER PHASE"

    # Unlock both for reviewer
    unlock_src
    unlock_tests

    local prompt
    prompt=$(reviewer_prompt)

    log_info "Invoking reviewer AI (new session)..."
    REVIEWER_SESSION_ID=$(uuidgen)
    claude -p \
        --session-id "$REVIEWER_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
        --append-system-prompt "You are the REVIEWER. You may modify both src/ and test/. All tests MUST pass after your changes. Focus on code quality improvements only." \
        "$prompt" 2>&1

    # Verify tests still pass after review
    log_info "Verifying tests still pass after review..."
    if run_tests; then
        log_success "Reviewer phase complete - all tests still pass"
        git add -A
        git commit -m "REVIEW: Code quality improvements after TDD-TCR loop" --no-verify 2>/dev/null || true
    else
        log_error "Reviewer broke tests! Reverting..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        log_warning "Reviewer changes reverted - tests must pass"
    fi

    lock_src
    lock_tests
}

main() {
    check_dependencies

    if [ -z "$REQUIREMENTS" ]; then
        echo "Usage: ./tdd-tcr-loop \"Feature requirements\""
        echo ""
        echo "Example:"
        echo "  ./tdd-tcr-loop \"Add a function to validate email addresses\""
        echo ""
        echo "This script enforces:"
        echo "  - TDD: Tests written first by Auditor AI"
        echo "  - TCR: Test && Commit || Revert on Implementer AI"
        echo "  - Filesystem locks prevent cheating"
        exit 1
    fi

    log_phase "TDD-TCR LOOP STARTING"
    echo "Language: $PROJECT_LANG"
    echo "Test command: $TEST_CMD"
    echo "Requirements source: $REQUIREMENTS_SOURCE"
    echo ""
    echo -e "${MAGENTA}TCR Discipline: Test && Commit || Revert${NC}"
    echo -e "${MAGENTA}Implementation changes are automatically reverted if tests fail${NC}"
    echo ""
    echo "Requirements:"
    echo "$REQUIREMENTS"
    echo ""

    # Ensure we have a clean git state to start
    log_info "Ensuring clean git state..."
    git add -A
    git commit -m "PRE-TDD-TCR: Savepoint before TDD-TCR loop" --no-verify 2>/dev/null || true

    # Initial lock
    lock_all

    local iteration=1
    local last_impl_result=""

    while true; do
        log_phase "TDD-TCR ITERATION $iteration"

        # Phase 1: Auditor writes/updates test
        if ! run_auditor "$iteration" "$last_impl_result"; then
            # Auditor signaled completion
            log_phase "TDD-TCR LOOP COMPLETE - ALL REQUIREMENTS MET"
            echo ""
            echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
            echo -e "${GREEN}  TCR STATISTICS${NC}"
            echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
            echo -e "  Commits: ${GREEN}$TCR_COMMITS${NC}"
            echo -e "  Reverts: ${RED}$TCR_REVERTS${NC}"
            echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
            echo ""

            log_success "Completed after $iteration iterations"

            # Now run the reviewer
            run_reviewer

            # Unlock everything at end
            chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
            chmod -R u+w "$TEST_DIR/" 2>/dev/null || true

            exit 0
        fi

        # Commit the new test
        git add -A
        git commit -m "TEST(tcr-$iteration): New test from auditor" --no-verify 2>/dev/null || true

        # Check if new test fails (as expected for red phase)
        log_info "Verifying test is RED (failing)..."

        if run_tests; then
            log_warning "Tests already pass - auditor should write a NEW failing test"
            log_info "Continuing to next iteration..."
            last_impl_result="All tests passed. Write a new failing test for uncovered requirements."
            iteration=$((iteration + 1))
            continue
        fi

        log_success "Test is RED - proceeding to implementation"

        # Phase 2: Implementer makes it pass (with TCR)
        if run_implementer "$LAST_TEST_OUTPUT" "$iteration"; then
            last_impl_result="Tests passed and committed. Ready for next test."
        else
            last_impl_result="Implementation failed after $MAX_IMPL_ATTEMPTS attempts (all reverted). Test may be too ambitious - consider smaller steps."
            log_warning "Continuing despite implementation failure..."
        fi

        iteration=$((iteration + 1))

        # Check if we've hit max iterations
        if [ $iteration -gt $MAX_ITERATIONS ]; then
            log_phase "MAX ITERATIONS REACHED ($MAX_ITERATIONS)"
            echo ""
            echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
            echo -e "${GREEN}  TCR STATISTICS${NC}"
            echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
            echo -e "  Commits: ${GREEN}$TCR_COMMITS${NC}"
            echo -e "  Reverts: ${RED}$TCR_REVERTS${NC}"
            echo -e "${GREEN}═══════════════════════════════════════════════════════════${NC}"
            echo ""

            log_success "Completed $((iteration - 1)) iterations"

            # Unlock everything at end
            chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
            chmod -R u+w "$TEST_DIR/" 2>/dev/null || true

            exit 0
        fi

        log_info "Automatically continuing to iteration $iteration..."
    done
}

# Cleanup on exit
cleanup() {
    log_info "Cleaning up locks..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true
}

trap cleanup EXIT

# Run
main
