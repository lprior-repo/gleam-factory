# TDD-TCR-REFACTOR Session History

This file tracks the reasoning from each agent to provide context to subsequent agents.

---


## Iteration 0 - SESSION START

Requirements: Enhance ALL modules in the factory-gleam codebase with targeted improvements:

AUDIT MODULE (src/audit.gleam):
1. Add audit_trail(bead: Bead, action: String) -> String
   - Format: '[timestamp] action: bead_slug'
2. Add validate_audit_entry(entry: String) -> Result(Nil, String)

CLI MODULE (src/cli.gleam):
3. Add parse_args(args: List(String)) -> Result(Command, String)
   - Pure function (testable without argv)
4. Add short flags: -s=--slug, -p=--priority

CONFIG MODULE (src/config.gleam):
5. Add with_data_dir(config: Config, dir: String) -> Config
6. Add merge_configs(base: Config, override: Config) -> Config

DOMAIN MODULE (src/domain.gleam):
7. Add bead_age_days(bead: Bead) -> Int
8. Add is_stale(bead: Bead, max_days: Int) -> Bool

ERRORS MODULE (src/errors.gleam):
9. Add format_error_context(err: String, file: String, line: Int) -> String
10. Add chain_errors(errors: List(String)) -> String

INTEGRATION MODULE (src/integration.gleam):
11. Add retry_with_backoff(f: fn() -> Result(a, e), retries: Int) -> Result(a, e)

PERSISTENCE MODULE (src/persistence.gleam):
12. Add backup_bead(bead: Bead, backup_dir: String) -> Result(Nil, String)

PROCESS MODULE (src/process.gleam):
13. Add run_with_timeout(cmd: String, timeout_ms: Int) -> Result(String, String)
14. Add capture_stderr(cmd: String) -> Result(#(String, String), String)

REPO MODULE (src/repo.gleam):
15. Add get_remote_url() -> Result(String, String)
16. Add is_clean() -> Result(Bool, String)

STAGES MODULE (src/stages.gleam):
17. Add validate_stage_transition(from: Stage, to: Stage) -> Result(Nil, String)

TCR MODULE (src/tcr.gleam):
18. Add tcr_stats() -> #(Int, Int) - returns (commits, reverts)

UTILS MODULE (src/utils.gleam):
19. Add truncate_string(s: String, max_len: Int) -> String
20. Add pad_left(s: String, width: Int, char: String) -> String

VALIDATION MODULE (src/validation.gleam):
21. Add validate_slug_format(slug: String) -> Result(String, String)
   - Must start with letter, only alphanumeric/underscores, max 50 chars
22. Add validate_priority(p: String) -> Result(Priority, String)
   - Accept P1/P2/P3, p1/p2/p3, 1/2/3

WORKTREE MODULE (src/worktree.gleam):
23. Add list_worktrees() -> Result(List(String), String)
24. Add cleanup_stale_worktrees(max_age_days: Int) -> Result(Int, String)

These span ALL 15 source modules with 24 functions total.

---

## Iteration 1 - AUDITOR

Excellent! Let me provide a summary of what I've done:

## TEST 1 COMPLETE: validate_slug_format validation

I've written a comprehensive test suite for the `validate_slug_format` function that will be in the new `validation` module. This test covers:

### Test Cases Written:
1. **Valid cases:**
   - `feature_123` - starts with letter, alphanumeric + underscore
   - `task_1_a_b_c` - multiple underscores and numbers
   - `a` + 49 `b`s = 50 char slug - at max length boundary

2. **Invalid cases (error conditions):**
   - `123_feature` - starts with number (must start with letter)
   - `_feature` - starts with underscore (must start with letter)
   - `feature-name` - contains hyphen (only alphanumeric and underscore allowed)
   - `feature@name` - contains special character
   - `a` + 50 `b`s = 51 char slug - exceeds 50 char max
   - Empty string

### Why This Test Design:
- **Tests ONE behavior**: Pure validation of slug format constraints
- **Drives clean design**: Forces implementer to write a focused validation function with clear rules
- **Comprehensive edge cases**: Covers all constraint boundaries (start char, allowed chars, max length)
- **Independent tests**: Each test is self-contained with a single assertion
- **Descriptive names**: Each test name clearly describes what it validates
- **Currently FAILS** ✓ - The validation module doesn't exist yet, so tests fail (red phase of TDD)

### Next Step:
The implementer will create `src/validation.gleam` with a `pub fn validate_slug_format(slug: String) -> Result(String, String)` function that validates these exact rules. The function should return `Ok(slug)` if valid, or `Error(reason)` if invalid.

---

## Iteration 1 (attempt 1) - IMPLEMENTER

Perfect! The tests are passing. Let me provide the summary:

## Summary

**What the test is asking for:**
The test suite requires a new `validation` module with a `validate_slug_format` function that validates slug format according to specific rules: must start with a letter, can only contain letters/numbers/underscores, max 50 characters, and cannot be empty.

**What I implemented:**
Created `src/validation.gleam` with a `validate_slug_format` function that validates all the test requirements. The implementation includes:
- Length validation (non-empty, max 50 chars)
- First character validation (must be a letter)
- Character set validation (only alphanumeric and underscore allowed)
- Helper functions to check if characters are valid

**Why this approach:**
The implementation uses simple pattern matching and recursive character checking, which is idiomatic in Gleam. It returns `Ok(slug)` for valid input and `Error(String)` for invalid cases, matching the Result type expected by the tests. All 24 tests pass, including the 9 new validation tests.

---

## Iteration 2 - AUDITOR

Perfect! The tests fail because the function doesn't exist. This is exactly what we want - the tests are now driving the design. The implementer will need to:

1. Define a `Priority` type in the validation module
2. Implement the `validate_priority` function that accepts P1, P2, P3, p1, p2, p3, 1, 2, 3 and rejects invalid inputs

Let me document what the test is testing:

## ITERATION 2 - TEST: validate_priority

**What's being tested:** The `validate_priority` function in the validation module

**Why this test matters:**
- Priority is a core domain concept used throughout the system (CLI, persistence, filtering)
- The function must accept multiple formats: uppercase (P1/P2/P3), lowercase (p1/p2/p3), and numeric (1/2/3)
- Invalid priorities must be rejected to prevent bad data from entering the system
- This test drives the creation of a `Priority` type that makes illegal states unrepresentable

**Test Design:**
- `validate_priority_accepts_uppercase_p1_test`: Valid priority in uppercase format returns Ok
- `validate_priority_accepts_lowercase_p1_test`: Valid priority in lowercase format returns Ok
- `validate_priority_accepts_numeric_1_test`: Valid priority in numeric format returns Ok
- `validate_priority_rejects_invalid_p4_test`: Invalid priority (P4) returns Error
- `validate_priority_rejects_empty_string_test`: Empty string returns Error

**Expected Implementation:**
The implementer should:
1. Define a `Priority` type with three variants: P1, P2, P3
2. Implement `validate_priority(p: String) -> Result(Priority, String)` that:
   - Normalizes input (lowercase/uppercase/numeric formats)
   - Returns Ok with the Priority variant if valid (P1, P2, or P3)
   - Returns Error with descriptive message if invalid

**Current Status:** Tests are RED (failing) - ready for implementation phase

---

## Iteration 2 (attempt 1) - IMPLEMENTER

Perfect! Here's what was implemented:

## What the test is asking for
The test requires a `validate_priority` function that accepts priority strings in multiple formats (uppercase P1/P2/P3, lowercase p1/p2/p3, or numeric 1/2/3) and rejects invalid inputs like "P4" or empty strings.

## What I implemented
1. **Added `Priority` type** with three variants: `P1`, `P2`, `P3` (lines 3-7 in validation.gleam)
2. **Implemented `validate_priority` function** that:
   - Normalizes input using `string.lowercase()` to handle both uppercase and lowercase formats
   - Maps "p1"/"1" → P1, "p2"/"2" → P2, "p3"/"3" → P3
   - Returns `Error("Priority cannot be empty")` for empty strings
   - Returns `Error("Invalid priority")` for any other input like "p4"

## Why this approach
This minimal implementation directly satisfies all 5 test cases by normalizing input and pattern matching on the lowercase representation. The `Priority` type makes the domain concept explicit while the function handles the validation logic cleanly with descriptive error messages.

---
