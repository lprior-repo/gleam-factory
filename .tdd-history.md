# TDD-TCR-REFACTOR Session History

This file tracks the reasoning from each agent to provide context to subsequent agents.

---


## Iteration 0 - SESSION START

Requirements: ## Implement GPU ticket system

Add request_gpu_ticket(governor) / release_gpu_ticket(governor, ticket). Ticket is simple counter. Block when no tickets available.

### Acceptance Criteria
Ticket acquisition blocks when exhausted, releases work

---

## Iteration 1 - AUDITOR

Test drives the implementation. The test forces:
1. BLOCKING semantics (not Error)
2. FAIRNESS queue (FIFO ordering)
3. RELEASE wakeup (ticket return enables blocked caller)
4. ACTOR state (counter + waiting queue)
5. COMPOSABILITY (governor|>request|>release)

#A{"s":"tw","t":{"n":"gpu_governor_blocks_when_exhausted_and_releases_on_free_test","f":"test/factory_test.gleam","b":"P-pure-release-restores,U-one-semaphore,C-compose-request-release,I-blocking-receive"},"c":0.9,"why":"Forces blocking+queue+wakeup, prevents trivial Ok return"}|{"s":"rc","c":1.0}

---

## Iteration 1 (attempt 1) - IMPLEMENTER

{"s":"bl","b":"test uses process.start_linked which doesn't exist","cf":0}

---

## Iteration 1 - TCR

REVERTED - compilation failed:   Compiling factory
error: Unknown module value
     ┌─ /home/lewis/src/factory-gleam/test/factory_test.gleam:2389:11
     │
2389 │   process.start_linked(fn() {
     │           ^^^^^^^^^^^^

The module `process` does not have a `start_linked` value.

---

## Iteration 1 (attempt 2) - IMPLEMENTER

#I{"s":"ok","c":[{"f":"src/process.gleam","a":"+","l":3}],"cf":0.95,"justify":"Import erl_process for spawn; add start_linked wrapper delegating to spawn; minimal code to pass test"}

---

## Iteration 2 - AUDITOR

#A{"s":"tw","t":{"n":"gpu_governor_rejects_invalid_ticket_release_test","f":"test/factory_test.gleam","b":"D"},"c":0.9,"why":"Forces opaque GpuTicket with validation: prevents Int forgery, enforces ownership check, detects double-release. Implementer must confront ticket identity tracking."}|{"s":"rc","c":1.0}

---

## Iteration 2 (attempt 1) - IMPLEMENTER

PASS.

{"s":"ok","c":[{"f":"src/types.gleam","a":"+","l":29}],"cf":0.95,"justify":"opaque GpuTicket+GpuGovernor w/gov_id, monotonic ticket counter, validates gov_id+ticket_id on release"}

---

## Iteration 3 - AUDITOR

#A{"s":"tw","t":{"n":"gpu_governor_ticket_composes_with_work_pipeline_test","f":"test/factory_test.gleam","b":"C(Compose)"},"c":0.95,"why":"Forces with_gpu_ticket helper that threads ticket through work fn, auto-releases, composable in pipeline. Rejects manual request/release, leakable resources."}|{"s":"rc","c":1.0}

---

## Iteration 3 (attempt 1) - IMPLEMENTER

```gleam
pub fn with_gpu_ticket(
  gov: Governor(resource_type, ticket_type),
  work: fn(ticket_type) -> Result(Nil, GpuError),
) -> Result(Nil, GpuError) {
  use ticket <- result.try(gov.acquire())
  let work_result = work(ticket)
  gov.release(ticket)
  work_result
}
```

```gleam
pub fn with_gpu_ticket(
  gov: Governor(resource_type, ticket_type),
  work: fn(ticket_type) -> Result(Nil, GpuError),
) -> Result(Nil, GpuError) {
  use ticket <- result.try(gov.acquire())
  let work_result = work(ticket)
  let _ = gov.release(ticket)
  work_result
}
```

#I{"s":"ok","c":[{"f":"src/types.gleam","a":"+","l":7}],"cf":0.85,"justify":"pattern=acquire-work-release bracket,pipes-acquire-thru-result,ignores-release-result-per-test-expectations"}

---

## Iteration 3 - TCR

REVERTED - compilation failed:   Compiling factory
error: Unknown module value
     ┌─ /home/lewis/src/factory-gleam/test/factory_test.gleam:2482:22
     │
2482 │   let result = types.with_gpu_ticket(gov, work_fn)
     │                      ^^^^^^^^^^^^^^^

The module `types` does not have a `with_gpu_ticket` value.

---

## Iteration 3 (attempt 2) - IMPLEMENTER

#I{"s":"ok","c":[{"f":"src/types.gleam","a":"+","l":8}],"cf":0.95,"justify":"with_gpu_ticket wraps request+work+release. use ticket extracts. result import needed. work_result stores before cleanup. underscore discards release result."}

---

## Iteration 3 - ARCHITECT

LOC:6398→6397 (-1) All fns <30 lines. All tests pass.

CHANGES:
1. Extracted gpu_rpc helper - DRY for request_gpu_ticket/release_gpu_ticket RPC pattern
2. Split 34-line gpu_loop into 5-line dispatcher
3. Extracted handle_request (8L) handle_release (9L) release_valid_ticket (13L)
4. Inlined ticket variable in handle_request

CUPID:
C=5 Small surface, |> pipes, low coupling
U=5 Single responsibility per fn
P=4 Pure except process I/O (unavoidable for actor)
I=5 Pattern match, Result types, opaque types
D=5 Domain names (GpuGovernor/Ticket/State)

#R{"s":"rf","lb":6398,"la":6397,"c":[{"t":"x","w":"DRY-extracted gpu_rpc for RPC pattern"},{"t":"s","w":"Split 34L gpu_loop into 5L dispatcher+handlers"},{"t":"i","w":"Inlined ticket variable"}],"cf":1.0,"cupid":[5,5,4,5,5],"sm":[]}

---

## Iteration 4 - AUDITOR

Test fails - implementation wakes wrong waiter. Forces FIFO queue fix.

#A{"s":"tw","t":{"n":"gpu_governor_unblocks_waiters_fifo_test","f":"test/factory_test.gleam","b":"U-fairness,I-actor-queue"},"c":0.95,"why":"waiter list is LIFO not FIFO"}|{"s":"rc","c":1.0}

---

## Iteration 4 (attempt 1) - IMPLEMENTER

```json
{"s":"ok","c":[{"f":"src/types.gleam","a":"+","l":1}],"cf":0.92,"justify":"append to tail preserves FIFO order"}
```

---

## Iteration 5 - AUDITOR

```gleam
pub fn gpu_ticket_sequential_release_reuse_test() {
  let gov = Governor(max_gpu_tickets: 1)
  
  let ticket1 = request_gpu_ticket(gov)
  release_gpu_ticket(gov, ticket1)
  
  let ticket2 = request_gpu_ticket(gov)
  release_gpu_ticket(gov, ticket2)
  
  let ticket3 = request_gpu_ticket(gov)
  
  ticket3
  |> should.be_ok
}
```

#A{"s":"tw","t":{"n":"gpu_ticket_sequential_release_reuse_test","f":"test/factory_test.gleam","b":"U+I: Forces pure state management without mutation, tickets must be independently valid"},"c":0.85,"why":"trivial counter fails if ticket IDs collide or state corrupts on reuse"}|{"s":"rc","c":0.95}

---
