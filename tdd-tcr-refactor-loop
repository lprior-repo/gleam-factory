#!/bin/bash
#
# TDD-TCR-REFACTOR Loop: Full Red-Green-Refactor with Architectural Oversight
#
# Four AI sessions with filesystem-enforced separation:
# - Auditor: writes tests (can't touch src/)
# - Implementer: writes code (can't touch test/) - with TCR enforcement
# - Architect: refactors after every N green cycles (ensures design quality)
# - Reviewer: final cleanup after completion
#
# The REFACTOR step is the key difference:
# - After every REFACTOR_INTERVAL successful implementations
# - Architect reviews and refactors both src/ AND tests
# - Must maintain all passing tests
# - Focuses on: DRY, patterns, idioms, architecture
#
# Usage:
#   ./tdd-tcr-refactor-loop "Feature description or requirements"
#   ./tdd-tcr-refactor-loop --bead <bead-id>      # Use bead issue as requirements
#   ./tdd-tcr-refactor-loop -b <bead-id>          # Short form
#   ./tdd-tcr-refactor-loop --all                 # Process ALL open beads (sorted by priority)
#   ./tdd-tcr-refactor-loop -a                    # Short form for --all
#

set -eo pipefail

#---------------------------------------------------------------------------
# Bead Issue Integration
#---------------------------------------------------------------------------
BEADS_DIR=".beads"
CURRENT_BEAD_ID=""
BEAD_MODE=false
ALL_BEADS_MODE=false
BEAD_JSON=""
BEAD_TITLE=""

# Track results across all beads
declare -a COMPLETED_BEADS=()
declare -a FAILED_BEADS=()
declare -a SKIPPED_BEADS=()

# Find bead by ID in .beads/*.jsonl files
find_bead() {
    local bead_id="$1"
    local bead_json=""

    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        bead_json=$(grep -h "\"id\":\"$bead_id\"" "$jsonl_file" 2>/dev/null | head -1)
        if [ -n "$bead_json" ]; then
            echo "$bead_json"
            return 0
        fi
    done
    return 1
}

# Get all open beads sorted by priority (P0 first, then P1, P2, etc.)
get_all_open_beads() {
    local all_beads=""

    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        # Get all lines with status "open", extract id and priority for sorting
        while IFS= read -r line; do
            if echo "$line" | jq -e 'select(.status == "open")' >/dev/null 2>&1; then
                local id=$(echo "$line" | jq -r '.id')
                local priority=$(echo "$line" | jq -r '.priority // 99')
                echo "$priority $id"
            fi
        done < "$jsonl_file"
    done | sort -n | cut -d' ' -f2
}

# Count open beads
count_open_beads() {
    get_all_open_beads | wc -l
}

# Extract field from bead JSON
bead_field() {
    local json="$1"
    local field="$2"
    echo "$json" | jq -r ".$field // empty" 2>/dev/null
}

# Update bead status in the jsonl file
update_bead_status() {
    local bead_id="$1"
    local new_status="$2"
    local close_reason="${3:-}"

    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        if grep -q "\"id\":\"$bead_id\"" "$jsonl_file" 2>/dev/null; then
            local tmp_file=$(mktemp)
            local now=$(date -Iseconds)

            while IFS= read -r line; do
                if echo "$line" | grep -q "\"id\":\"$bead_id\""; then
                    # Update status
                    line=$(echo "$line" | jq -c ".status = \"$new_status\" | .updated_at = \"$now\"")
                    # Add close fields if closing
                    if [ "$new_status" = "closed" ] && [ -n "$close_reason" ]; then
                        line=$(echo "$line" | jq -c ".closed_at = \"$now\" | .close_reason = \"$close_reason\"")
                    fi
                fi
                echo "$line"
            done < "$jsonl_file" > "$tmp_file"

            mv "$tmp_file" "$jsonl_file"
            return 0
        fi
    done
    return 1
}

# Build requirements string from bead fields
build_requirements_from_bead() {
    local bead_json="$1"
    local title=$(bead_field "$bead_json" "title")
    local description=$(bead_field "$bead_json" "description")
    local acceptance=$(bead_field "$bead_json" "acceptance_criteria")

    cat <<EOF
## $title

$description

### Acceptance Criteria
$acceptance
EOF
}

# Parse --bead/-b argument
parse_bead_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bead|-b)
                BEAD_MODE=true
                CURRENT_BEAD_ID="$2"
                shift 2
                ;;
            *)
                # Not a bead arg, return remaining args
                echo "$@"
                return
                ;;
        esac
    done
}

# Dependency checks
check_dependencies() {
    local missing=()
    command -v claude >/dev/null 2>&1 || missing+=("claude")
    command -v uuidgen >/dev/null 2>&1 || missing+=("uuidgen")
    command -v jq >/dev/null 2>&1 || missing+=("jq")
    git rev-parse --git-dir >/dev/null 2>&1 || missing+=("git (not in a repository)")

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Missing dependencies: ${missing[*]}"
        exit 1
    fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
NC='\033[0m' # No Color

# Background colors
BG_RED='\033[41m'
BG_GREEN='\033[42m'
BG_YELLOW='\033[43m'
BG_BLUE='\033[44m'
BG_MAGENTA='\033[45m'
BG_CYAN='\033[46m'
BG_WHITE='\033[47m'

# Box drawing characters
BOX_TL='â•”'
BOX_TR='â•—'
BOX_BL='â•š'
BOX_BR='â•'
BOX_H='â•'
BOX_V='â•‘'
BOX_LT='â• '
BOX_RT='â•£'

# Progress indicators
SPINNER_CHARS='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
PROGRESS_FULL='â–ˆ'
PROGRESS_EMPTY='â–‘'

# Configuration
SRC_DIR="src"
TEST_DIR="test"
MAX_IMPL_ATTEMPTS=3
MAX_ITERATIONS=15
REFACTOR_INTERVAL=3  # Run architect every N successful implementations

# Handle requirements from bead, file, or argument
REQUIREMENTS=""
REQUIREMENTS_SOURCE=""

# Setup a single bead for processing
setup_bead() {
    local bead_id="$1"
    CURRENT_BEAD_ID="$bead_id"
    BEAD_MODE=true

    BEAD_JSON=$(find_bead "$CURRENT_BEAD_ID")
    if [ -z "$BEAD_JSON" ]; then
        echo "Error: Bead '$CURRENT_BEAD_ID' not found in $BEADS_DIR/"
        return 1
    fi

    BEAD_STATUS=$(bead_field "$BEAD_JSON" "status")
    if [ "$BEAD_STATUS" != "open" ]; then
        echo "Skipping bead '$CURRENT_BEAD_ID' - status is '$BEAD_STATUS' (not 'open')"
        return 2
    fi

    REQUIREMENTS=$(build_requirements_from_bead "$BEAD_JSON")
    REQUIREMENTS_SOURCE="bead: $CURRENT_BEAD_ID"
    BEAD_TITLE=$(bead_field "$BEAD_JSON" "title")

    # Reset statistics for this bead
    TCR_COMMITS=0
    TCR_REVERTS=0
    REFACTOR_COUNT=0
    SUCCESSFUL_IMPLS=0

    return 0
}

# Check for --all mode first
if [ "$1" = "--all" ] || [ "$1" = "-a" ]; then
    ALL_BEADS_MODE=true
    BEAD_MODE=true
# Check for single bead mode
elif [ "$1" = "--bead" ] || [ "$1" = "-b" ]; then
    BEAD_MODE=true
    CURRENT_BEAD_ID="$2"

    if [ -z "$CURRENT_BEAD_ID" ]; then
        echo "Error: --bead requires a bead ID"
        exit 1
    fi

    BEAD_JSON=$(find_bead "$CURRENT_BEAD_ID")
    if [ -z "$BEAD_JSON" ]; then
        echo "Error: Bead '$CURRENT_BEAD_ID' not found in $BEADS_DIR/"
        exit 1
    fi

    BEAD_STATUS=$(bead_field "$BEAD_JSON" "status")
    if [ "$BEAD_STATUS" != "open" ]; then
        echo "Warning: Bead '$CURRENT_BEAD_ID' has status '$BEAD_STATUS' (not 'open')"
        read -p "Continue anyway? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi

    REQUIREMENTS=$(build_requirements_from_bead "$BEAD_JSON")
    REQUIREMENTS_SOURCE="bead: $CURRENT_BEAD_ID"
    BEAD_TITLE=$(bead_field "$BEAD_JSON" "title")
elif [ -f "$1" ]; then
    REQUIREMENTS=$(cat "$1")
    REQUIREMENTS_SOURCE="file: $1"
else
    REQUIREMENTS="$1"
    REQUIREMENTS_SOURCE="argument"
fi

# Detect language from project files
detect_language() {
    if [ -f "gleam.toml" ]; then
        echo "gleam"
    elif [ -f "go.mod" ]; then
        echo "go"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
        echo "python"
    else
        echo "unknown"
    fi
}

PROJECT_LANG=$(detect_language)
TEST_CMD="gleam test"
case "$PROJECT_LANG" in
    gleam) TEST_CMD="gleam test" ;;
    go) TEST_CMD="go test ./..." ;;
    rust) TEST_CMD="cargo test" ;;
    python) TEST_CMD="pytest" ;;
esac

# Statistics
TCR_COMMITS=0
TCR_REVERTS=0
REFACTOR_COUNT=0
SUCCESSFUL_IMPLS=0

# Context passing between agents
HISTORY_FILE=".tdd-history.md"
LAST_AUDITOR_REASONING=""
LAST_IMPL_REASONING=""

# Initialize history file
init_history() {
    cat > "$HISTORY_FILE" << 'HISTEOF'
# TDD-TCR-REFACTOR Session History

This file tracks the reasoning from each agent to provide context to subsequent agents.

---

HISTEOF
}

# Append to history
append_history() {
    local role="$1"
    local iteration="$2"
    local content="$3"

    echo "" >> "$HISTORY_FILE"
    echo "## Iteration $iteration - $role" >> "$HISTORY_FILE"
    echo "" >> "$HISTORY_FILE"
    echo "$content" >> "$HISTORY_FILE"
    echo "" >> "$HISTORY_FILE"
    echo "---" >> "$HISTORY_FILE"
}

# Get recent history (last N entries, trimmed for context window)
get_recent_history() {
    local max_lines="${1:-100}"
    tail -n "$max_lines" "$HISTORY_FILE" 2>/dev/null || echo "(no history yet)"
}

#---------------------------------------------------------------------------
# Utility functions
#---------------------------------------------------------------------------

# Get terminal width
get_term_width() {
    tput cols 2>/dev/null || echo 80
}

# Draw a horizontal line
draw_line() {
    local char="${1:-â•}"
    local width="${2:-$(get_term_width)}"
    printf '%*s' "$width" '' | tr ' ' "$char"
}

# Center text
center_text() {
    local text="$1"
    local width="${2:-$(get_term_width)}"
    local text_len=${#text}
    local padding=$(( (width - text_len) / 2 ))
    printf '%*s%s' "$padding" '' "$text"
}

# Draw fancy box
draw_box() {
    local title="$1"
    local color="$2"
    local width=$(get_term_width)
    local inner_width=$((width - 4))

    echo ""
    echo -e "${color}â•”$(draw_line 'â•' $((width-2)))â•—${NC}"
    echo -e "${color}â•‘$(center_text "$title" $((width-2)))â•‘${NC}"
    echo -e "${color}â•š$(draw_line 'â•' $((width-2)))â•${NC}"
    echo ""
}

# Draw status dashboard
draw_dashboard() {
    local iteration="$1"
    local width=$(get_term_width)

    echo -e "${DIM}$(draw_line 'â”€' $width)${NC}"
    echo -e "${BOLD}  ğŸ“Š DASHBOARD${NC}  â”‚  Iteration: ${CYAN}$iteration${NC}  â”‚  Commits: ${GREEN}$TCR_COMMITS${NC}  â”‚  Reverts: ${RED}$TCR_REVERTS${NC}  â”‚  Refactors: ${WHITE}$REFACTOR_COUNT${NC}"
    echo -e "${DIM}$(draw_line 'â”€' $width)${NC}"
}

# Progress bar
draw_progress() {
    local current="$1"
    local total="$2"
    local width=30
    local filled=$((current * width / total))
    local empty=$((width - filled))
    local percent=$((current * 100 / total))

    printf "${CYAN}["
    printf '%*s' "$filled" '' | tr ' ' "$PROGRESS_FULL"
    printf '%*s' "$empty" '' | tr ' ' "$PROGRESS_EMPTY"
    printf "] ${WHITE}%3d%%${NC}" "$percent"
}

log_phase() {
    local title="$1"
    draw_box "$title" "${BLUE}"
}

log_auditor() {
    echo ""
    echo -e "${YELLOW}â”Œ$(draw_line 'â”€' 58)â”${NC}"
    echo -e "${YELLOW}â”‚  ğŸ” AUDITOR: ${BOLD}$1${NC}${YELLOW}$(printf '%*s' $((44 - ${#1})) '')â”‚${NC}"
    echo -e "${YELLOW}â””$(draw_line 'â”€' 58)â”˜${NC}"
    echo ""
}

log_implementer() {
    echo ""
    echo -e "${GREEN}â”Œ$(draw_line 'â”€' 58)â”${NC}"
    echo -e "${GREEN}â”‚  ğŸ”§ IMPLEMENTER: ${BOLD}$1${NC}${GREEN}$(printf '%*s' $((40 - ${#1})) '')â”‚${NC}"
    echo -e "${GREEN}â””$(draw_line 'â”€' 58)â”˜${NC}"
    echo ""
}

log_architect() {
    echo ""
    echo -e "${WHITE}${BOLD}â•”$(draw_line 'â•' 58)â•—${NC}"
    echo -e "${WHITE}${BOLD}â•‘  ğŸ›ï¸  ARCHITECT: $1$(printf '%*s' $((40 - ${#1})) '')â•‘${NC}"
    echo -e "${WHITE}${BOLD}â•š$(draw_line 'â•' 58)â•${NC}"
    echo ""
}

log_reviewer() {
    echo ""
    echo -e "${MAGENTA}â•”$(draw_line 'â•' 58)â•—${NC}"
    echo -e "${MAGENTA}â•‘  ğŸ“‹ REVIEWER: ${BOLD}$1${NC}${MAGENTA}$(printf '%*s' $((42 - ${#1})) '')â•‘${NC}"
    echo -e "${MAGENTA}â•š$(draw_line 'â•' 58)â•${NC}"
    echo ""
}

log_info() {
    echo -e "  ${CYAN}â†’${NC} $1"
}

log_success() {
    echo -e "  ${GREEN}âœ“${NC} ${GREEN}$1${NC}"
}

log_warning() {
    echo -e "  ${YELLOW}âš ${NC} ${YELLOW}$1${NC}"
}

log_error() {
    echo -e "  ${RED}âœ—${NC} ${RED}$1${NC}"
}

log_tcr() {
    echo -e "  ${MAGENTA}âŸ³${NC} ${BOLD}TCR:${NC} $1"
}

log_tdd_phase() {
    local phase="$1"
    local color="$2"
    local emoji="$3"
    echo -e "\n  ${color}${emoji} ${BOLD}${phase}${NC}"
}

# Show TDD cycle indicator
show_tdd_cycle() {
    local phase="$1"  # red, green, refactor
    local r_color="${DIM}"
    local g_color="${DIM}"
    local f_color="${DIM}"

    case "$phase" in
        red) r_color="${RED}${BOLD}" ;;
        green) g_color="${GREEN}${BOLD}" ;;
        refactor) f_color="${WHITE}${BOLD}" ;;
    esac

    echo -e "\n  TDD Cycle: [${r_color}RED${NC}] â†’ [${g_color}GREEN${NC}] â†’ [${f_color}REFACTOR${NC}]"
}

#---------------------------------------------------------------------------
# Lock management
#---------------------------------------------------------------------------

lock_all() {
    log_info "Locking all source and test files..."
    chmod -R a-w "$SRC_DIR/" 2>/dev/null || true
    chmod -R a-w "$TEST_DIR/" 2>/dev/null || true
}

unlock_src() {
    log_info "Unlocking src/ for implementer..."
    chmod -R u+w "$SRC_DIR/"
}

lock_src() {
    log_info "Locking src/..."
    chmod -R a-w "$SRC_DIR/"
}

unlock_tests() {
    log_info "Unlocking test/ for auditor..."
    chmod -R u+w "$TEST_DIR/"
}

lock_tests() {
    log_info "Locking test/..."
    chmod -R a-w "$TEST_DIR/"
}

unlock_all() {
    log_info "Unlocking all files..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true
}

#---------------------------------------------------------------------------
# Git/TCR operations
#---------------------------------------------------------------------------

tcr_commit() {
    local iteration="$1"
    local message="$2"

    log_tcr "Tests PASSED - Committing changes..."
    git add -A
    git commit -m "PASS(tcr-$iteration): $message" --no-verify 2>/dev/null || true
    TCR_COMMITS=$((TCR_COMMITS + 1))
    log_success "TCR Commit #$TCR_COMMITS"
}

tcr_revert() {
    local iteration="$1"

    log_tcr "Tests FAILED - Reverting implementation changes..."
    git checkout HEAD -- "$SRC_DIR/" 2>/dev/null || true
    git clean -fd "$SRC_DIR/" 2>/dev/null || true
    TCR_REVERTS=$((TCR_REVERTS + 1))
    log_error "TCR Revert #$TCR_REVERTS - Implementation discarded"
}

#---------------------------------------------------------------------------
# Test execution
#---------------------------------------------------------------------------

# Run tests and capture output. Sets LAST_TEST_OUTPUT and returns exit code.
run_tests() {
    log_info "Running tests ($TEST_CMD)..."
    LAST_TEST_OUTPUT=$($TEST_CMD 2>&1) && return 0 || return 1
}

# Run tests silently, just for pass/fail check
run_tests_quiet() {
    $TEST_CMD >/dev/null 2>&1
}

#---------------------------------------------------------------------------
# AI Prompts
#---------------------------------------------------------------------------

auditor_prompt() {
    local iteration="$1"
    local last_impl_result="$2"

    cat <<EOF
You are the AUDITOR in a TDD-TCR-REFACTOR loop. Your job is to write tests.

PROJECT: $PROJECT_LANG project
TEST COMMAND: $TEST_CMD

REQUIREMENTS:
$REQUIREMENTS

ITERATION: $iteration

YOUR CONSTRAINTS:
- You can ONLY modify files in test/
- You CANNOT modify files in src/ (read-only, filesystem enforced)
- Write ONE focused test at a time
- The test should FAIL initially (red phase of TDD)

YOUR TASK:
1. Read the current src/ code to understand what exists
2. Read the current tests to understand what's covered
3. Write EXACTLY ONE test that:
   - Tests ONE specific behavior or edge case
   - Drives better code design (not just coverage)
   - Forces the implementer to write clean, focused code
   - Follows testing best practices (arrange-act-assert, descriptive names)

TEST DESIGN PRINCIPLES:
- Each test should validate ONE thing
- Test names should describe the behavior being tested
- Tests should be independent and not rely on each other
- Prefer testing behavior over implementation details
- Edge cases matter: empty inputs, boundaries, error conditions

TCR CONTEXT:
The implementer is under TCR discipline - if they fail tests, their code is REVERTED.
Write tests that are:
- Clear enough that the implementer knows exactly what to build
- Focused enough that they can be implemented in one small step
- Strict enough that they catch real bugs

ARCHITECTURAL NOTE:
An ARCHITECT will review the code every $REFACTOR_INTERVAL iterations.
Write tests that encourage good architecture, not just passing behavior.
If you see the implementer taking shortcuts, write tests that force proper design.

IMPORTANT: Write ONLY ONE test per iteration. If ALL requirements are fully tested and implemented, output EXACTLY:
REQUIREMENTS_COMPLETE
and do not write any new tests.

$(if [ -n "$last_impl_result" ]; then
    echo "LAST IMPLEMENTATION RESULT:"
    echo "$last_impl_result"
    echo ""
    echo "If tests passed, write the next test for uncovered requirements."
    echo "If tests failed and were REVERTED, consider if your test was too ambitious."
fi)

OUTPUT: Only modify test files. Explain what you're testing and why.
EOF
}

implementer_prompt() {
    local test_output="$1"
    local attempt="$2"
    local auditor_reasoning="$3"

    cat <<EOF
You are the IMPLEMENTER in a TDD-TCR-REFACTOR loop. Your job is to make tests pass.

PROJECT: $PROJECT_LANG project
TEST COMMAND: $TEST_CMD

âš ï¸  TCR DISCIPLINE IS ENFORCED âš ï¸
- If tests PASS after your changes â†’ your code is COMMITTED automatically
- If tests FAIL after your changes â†’ your code is REVERTED automatically
- There is NO escape. Write code that works or it disappears.

YOUR CONSTRAINTS:
- You can ONLY modify files in src/
- You CANNOT modify files in test/ (read-only, filesystem enforced)
- Write the MINIMUM code to make tests pass
- Follow existing patterns in the codebase

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    AUDITOR'S REASONING (why this test exists)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

$auditor_reasoning

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CURRENT TEST OUTPUT:
$test_output

ATTEMPT: $attempt of $MAX_IMPL_ATTEMPTS

YOUR TASK:
1. Read the AUDITOR'S REASONING above - understand WHY this test matters
2. Read the failing test to understand what's expected
3. Read the current src/ code
4. Write the MINIMUM code to make ONLY this test pass
5. Do NOT over-engineer or add untested features

IMPLEMENTATION PRINCIPLES:
- Write only what the test demands - nothing more
- Keep functions small and focused
- Use descriptive names that explain intent
- Handle the specific case the test covers
- The Architect will refactor shortcuts - just make it work first

REMEMBER: Your code will be REVERTED if tests fail. Be precise. Be minimal. Be correct.

OUTPUT FORMAT (required):
1. What the test is asking for (1-2 sentences)
2. What you implemented (code changes)
3. Why this approach (1-2 sentences)
EOF
}

architect_prompt() {
    local iteration="$1"
    local session_history="$2"

    cat <<EOF
You are the ARCHITECT in a TDD-TCR-REFACTOR loop. This is the REFACTOR phase.

PROJECT: $PROJECT_LANG project (Gleam - functional, immutable, BEAM)
TEST COMMAND: $TEST_CMD

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              SESSION HISTORY (what happened in previous iterations)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

$session_history

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        CODE IS A LIABILITY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Every line of code is:
- A line that can have bugs
- A line someone must read and understand
- A line that must be maintained forever
- A line that slows down compilation
- A line that increases cognitive load

YOUR PRIME DIRECTIVE: MINIMIZE CODE WHILE MAXIMIZING CLARITY

The best code is no code. The second best is the least code that works.
Every single line must EARN ITS PLACE or be deleted.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                              CUPID PROPERTIES
                    (Dan North's properties for joyful code)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

C - COMPOSABLE: Small surface area, minimal dependencies, plays well with others
    â†’ Functions take simple inputs, return simple outputs
    â†’ No hidden state, no side effects in core logic
    â†’ Easy to combine with other functions via |> pipes

U - UNIX PHILOSOPHY: Do one thing well
    â†’ Each function has ONE job
    â†’ If you need "and" to describe it, split it
    â†’ Small, focused, predictable

P - PREDICTABLE: Same input â†’ same output, always
    â†’ Pure functions wherever possible
    â†’ No surprises, no magic
    â†’ Deterministic behavior

I - IDIOMATIC: Feels natural for Gleam
    â†’ Use |> pipelines liberally
    â†’ Pattern matching over conditionals
    â†’ Result/Option for errors, not exceptions
    â†’ let bindings, use expressions
    â†’ Gleam stdlib over custom implementations

D - DOMAIN-BASED: Code speaks the language of the problem
    â†’ Types named after domain concepts
    â†’ Functions describe domain operations
    â†’ No technical jargon leaking into domain code

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    FUNCTIONAL CORE / IMPERATIVE SHELL
                         (Pragmatic Programmer pattern)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FUNCTIONAL CORE (pure, testable, the heart):
- All business logic is PURE functions
- No IO, no side effects, no external calls
- Takes data in, returns data out
- This is where 90% of your code should live
- Trivially testable without mocks

IMPERATIVE SHELL (thin, at the edges):
- IO operations (file, network, stdin/stdout)
- Wiring pure functions together
- Error handling at boundaries
- As THIN as possible - just plumbing

BOUNDARY RULES:
- Shell calls Core, never Core calls Shell
- Parse, don't validate (make illegal states unrepresentable)
- Push IO to the edges, keep the middle pure

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                           HARD LIMITS (ENFORCED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–¡ NO function over 30 lines (if longer, decompose)
â–¡ NO function doing 2+ things (split it)
â–¡ NO repeated code patterns (extract or delete)
â–¡ NO stringly-typed data (create proper types)
â–¡ NO imperative logic in core (make it functional)
â–¡ NO complex conditionals (pattern match instead)
â–¡ NO comments explaining WHAT (code should be clear)
â–¡ NO unused code (delete it)
â–¡ NO unnecessary abstractions (YAGNI)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                              YOUR TASK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Read ALL code that was added/modified
2. For EACH piece of code, ask:
   - Can this be DELETED? (best option)
   - Can this be SIMPLIFIED? (second best)
   - Can this be COMBINED with existing code? (DRY)
   - Is this PURE? If not, can it be made pure?
   - Does this follow CUPID properties?
   - Is this under 30 lines?
   - Would a Gleam expert write it this way?

3. REFACTOR ruthlessly:
   - Delete everything unnecessary
   - Simplify everything complex
   - Extract only when it REDUCES total code
   - Use Gleam stdlib functions (list.map, result.try, etc.)
   - Make it look like a world-class Gleam programmer wrote it

4. Run tests after changes - if they break, try differently

CURRENT STATE:
- Iteration: $iteration
- Successful implementations: $SUCCESSFUL_IMPLS
- TCR Commits: $TCR_COMMITS
- TCR Reverts: $TCR_REVERTS

ORIGINAL REQUIREMENTS:
$REQUIREMENTS

OUTPUT:
1. Lines of code BEFORE refactoring (count them)
2. What you DELETED and why
3. What you SIMPLIFIED and why
4. Lines of code AFTER refactoring
5. Net change (should be NEGATIVE or zero)
6. Test confirmation
EOF
}

reviewer_prompt() {
    local bead_context=""
    if [ "$BEAD_MODE" = true ]; then
        local acceptance=$(bead_field "$BEAD_JSON" "acceptance_criteria")
        bead_context=$(cat <<BEADEOF

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    BEAD ACCEPTANCE CRITERIA (MUST VERIFY)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Bead ID: $CURRENT_BEAD_ID
Title: $BEAD_TITLE

ACCEPTANCE CRITERIA:
$acceptance

YOU MUST EXPLICITLY VERIFY EACH ACCEPTANCE CRITERION AND OUTPUT:
- ACCEPTANCE_CRITERIA_MET: true/false
- For each criterion, explain HOW it was verified (test name, code location, etc.)
- If ANY criterion is NOT met, set ACCEPTANCE_CRITERIA_MET: false

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BEADEOF
)
    fi

    cat <<EOF
You are the REVIEWER. The TDD-TCR-REFACTOR loop has completed.

PROJECT: $PROJECT_LANG project
TEST COMMAND: $TEST_CMD

ORIGINAL REQUIREMENTS:
$REQUIREMENTS
$bead_context

FINAL STATISTICS:
- Total iterations: completed
- TCR Commits: $TCR_COMMITS
- TCR Reverts: $TCR_REVERTS
- Architect refactors: $REFACTOR_COUNT

YOUR TASK:
1. Final review of all code in src/ and test/
2. Check that all requirements are met
3. Look for any remaining issues:
   - Security concerns
   - Edge cases not covered by tests
   - Documentation gaps
   - API ergonomics
4. Make final polish improvements
5. Run '$TEST_CMD' to verify everything still passes

CONSTRAINTS:
- You may modify both src/ and test/
- All tests MUST still pass after your changes
- This is the FINAL review - be thorough
- Focus on production readiness

OUTPUT FORMAT (REQUIRED):
1. Summary of what was built
2. Any final changes made
3. ACCEPTANCE_CRITERIA_MET: true OR ACCEPTANCE_CRITERIA_MET: false
4. Verification details for each acceptance criterion
5. Any remaining concerns or TODOs

LEARNINGS (for future AI sessions):
After your review, output a section called "## AI LEARNINGS" that captures:
- What worked well in this implementation
- What patterns should be reused
- What pitfalls to avoid
- Specific Gleam/language idioms discovered
This will be saved to help future AI sessions on this codebase.
EOF
}

#---------------------------------------------------------------------------
# AI Session Runners
#---------------------------------------------------------------------------

run_auditor() {
    local iteration="$1"
    local last_result="$2"
    local prompt

    show_tdd_cycle "red"
    log_auditor "Writing failing test (Iteration $iteration)"
    draw_dashboard "$iteration"

    lock_src
    unlock_tests

    prompt=$(auditor_prompt "$iteration" "$last_result")

    log_info "Invoking auditor AI (new session, haiku-4.5)..."
    AUDITOR_SESSION_ID=$(uuidgen)
    auditor_output=$(claude -p \
        --model claude-haiku-4-5-20250514 \
        --session-id "$AUDITOR_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
        --append-system-prompt "You are the AUDITOR. You may ONLY modify files in test/. Any attempt to modify src/ will fail. Focus on writing ONE failing test that drives good design. If all requirements are met, output REQUIREMENTS_COMPLETE." \
        "$prompt" 2>&1)

    echo "$auditor_output"

    # Save auditor's reasoning to history for implementer
    LAST_AUDITOR_REASONING="$auditor_output"
    append_history "AUDITOR" "$iteration" "$auditor_output"

    lock_tests

    if echo "$auditor_output" | grep -q "REQUIREMENTS_COMPLETE"; then
        log_success "Auditor reports all requirements are complete!"
        return 1
    fi

    log_success "Auditor phase complete"
    return 0
}

run_implementer() {
    local test_output="$1"
    local iteration="$2"
    local attempt=1

    show_tdd_cycle "green"
    log_implementer "Making test pass (Iteration $iteration)"
    draw_dashboard "$iteration"

    while [ $attempt -le $MAX_IMPL_ATTEMPTS ]; do
        log_info "Implementation attempt $attempt of $MAX_IMPL_ATTEMPTS $(draw_progress $attempt $MAX_IMPL_ATTEMPTS)"

        lock_tests
        unlock_src

        log_tcr "Recording pre-implementation state..."

        # Pass auditor's reasoning to implementer
        prompt=$(implementer_prompt "$test_output" "$attempt" "$LAST_AUDITOR_REASONING")

        log_info "Invoking implementer AI (new session, haiku-4.5)..."
        IMPLEMENTER_SESSION_ID=$(uuidgen)
        impl_output=$(claude -p \
            --model claude-haiku-4-5-20250514 \
            --session-id "$IMPLEMENTER_SESSION_ID" \
            --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
            --append-system-prompt "You are the IMPLEMENTER under TCR discipline. You may ONLY modify files in src/. If tests fail, your changes will be REVERTED. Write MINIMUM code to pass the test." \
            "$prompt" 2>&1)

        echo "$impl_output"

        # Save implementer's reasoning to history
        append_history "IMPLEMENTER" "$iteration (attempt $attempt)" "$impl_output"

        lock_src

        log_phase "TCR CHECK"
        log_info "Running tests to determine commit or revert..."

        if run_tests; then
            tcr_commit "$iteration" "Implemented for iteration $iteration"
            log_success "Tests pass! Implementation committed."
            SUCCESSFUL_IMPLS=$((SUCCESSFUL_IMPLS + 1))
            return 0
        else
            tcr_revert "$iteration"
            append_history "TCR" "$iteration" "REVERTED - tests failed"
            test_output="$LAST_TEST_OUTPUT"
            attempt=$((attempt + 1))

            if [ $attempt -le $MAX_IMPL_ATTEMPTS ]; then
                log_warning "Trying again with fresh implementation..."
            fi
        fi
    done

    log_error "Implementer failed after $MAX_IMPL_ATTEMPTS attempts (all reverted)"
    return 1
}

run_architect() {
    local iteration="$1"

    show_tdd_cycle "refactor"
    log_architect "REFACTOR PHASE (after $SUCCESSFUL_IMPLS green cycles)"
    draw_dashboard "$iteration"

    unlock_all

    # Get session history for architect context
    local session_history
    session_history=$(get_recent_history 200)

    prompt=$(architect_prompt "$iteration" "$session_history")

    log_info "Invoking architect AI (new session, haiku-4.5)..."
    ARCHITECT_SESSION_ID=$(uuidgen)
    architect_output=$(claude -p \
        --model claude-haiku-4-5-20250514 \
        --session-id "$ARCHITECT_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
        --append-system-prompt "You are the ARCHITECT. You may modify both src/ and test/. Your job is to REFACTOR the code for quality and maintainability. ALL TESTS MUST STILL PASS. Focus on CUPID, code minimization, and idiomatic patterns. Every line must earn its place." \
        "$prompt" 2>&1)

    echo "$architect_output"

    # Save architect's reasoning to history
    append_history "ARCHITECT" "$iteration" "$architect_output"

    log_info "Verifying tests still pass after refactoring..."
    if run_tests; then
        log_success "Architect refactoring complete - all tests still pass"
        git add -A
        git commit -m "REFACTOR(architect-$REFACTOR_COUNT): Architectural improvements" --no-verify 2>/dev/null || true
        REFACTOR_COUNT=$((REFACTOR_COUNT + 1))
    else
        log_error "Architect broke tests! Reverting all changes..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        git clean -fd "$SRC_DIR/" "$TEST_DIR/" 2>/dev/null || true
        append_history "ARCHITECT" "$iteration" "REVERTED - tests broke after refactoring"
        log_warning "Architect changes reverted - tests must pass"
    fi

    lock_all
}

REVIEWER_VERDICT=""
REVIEWER_OUTPUT=""

run_reviewer() {
    log_reviewer "Final Production Polish"
    draw_dashboard "FINAL"

    unlock_all

    prompt=$(reviewer_prompt)

    log_info "Invoking reviewer AI (new session, haiku-4.5)..."
    REVIEWER_SESSION_ID=$(uuidgen)
    REVIEWER_OUTPUT=$(claude -p \
        --model claude-haiku-4-5-20250514 \
        --session-id "$REVIEWER_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*)" \
        --append-system-prompt "You are the REVIEWER doing final review. You may modify both src/ and test/. All tests MUST pass. Focus on production readiness and polish. You MUST output ACCEPTANCE_CRITERIA_MET: true or ACCEPTANCE_CRITERIA_MET: false in your response." \
        "$prompt" 2>&1)

    echo "$REVIEWER_OUTPUT"

    # Extract acceptance criteria verdict
    if echo "$REVIEWER_OUTPUT" | grep -q "ACCEPTANCE_CRITERIA_MET: true"; then
        REVIEWER_VERDICT="passed"
        log_success "Reviewer confirms: ACCEPTANCE CRITERIA MET"
    elif echo "$REVIEWER_OUTPUT" | grep -q "ACCEPTANCE_CRITERIA_MET: false"; then
        REVIEWER_VERDICT="failed"
        log_error "Reviewer reports: ACCEPTANCE CRITERIA NOT MET"
    else
        REVIEWER_VERDICT="unknown"
        log_warning "Reviewer did not clearly state acceptance criteria verdict"
    fi

    # Save AI learnings if present
    if echo "$REVIEWER_OUTPUT" | grep -q "## AI LEARNINGS"; then
        log_info "Saving AI learnings to .ai-learnings.md..."
        local learnings_file=".ai-learnings.md"
        local timestamp=$(date -Iseconds)
        local bead_info=""
        if [ "$BEAD_MODE" = true ]; then
            bead_info="Bead: $CURRENT_BEAD_ID ($BEAD_TITLE)"
        fi

        {
            echo ""
            echo "---"
            echo ""
            echo "## Session: $timestamp"
            [ -n "$bead_info" ] && echo "$bead_info"
            echo "Stats: $TCR_COMMITS commits, $TCR_REVERTS reverts, $REFACTOR_COUNT refactors"
            echo ""
            echo "$REVIEWER_OUTPUT" | sed -n '/## AI LEARNINGS/,/^## /p' | head -n -1
        } >> "$learnings_file"
        log_success "AI learnings saved to $learnings_file"
    fi

    log_info "Verifying tests still pass after review..."
    if run_tests; then
        log_success "Final review complete - all tests still pass"
        git add -A
        git commit -m "REVIEW: Final polish and review" --no-verify 2>/dev/null || true
    else
        log_error "Reviewer broke tests! Reverting..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        log_warning "Reviewer changes reverted - tests must pass"
    fi

    lock_all
}

#---------------------------------------------------------------------------
# Main Loop
#---------------------------------------------------------------------------

# Show usage help
show_usage() {
    echo "Usage: ./tdd-tcr-refactor-loop \"Feature requirements\""
    echo "       ./tdd-tcr-refactor-loop --bead <bead-id>"
    echo "       ./tdd-tcr-refactor-loop -b <bead-id>"
    echo "       ./tdd-tcr-refactor-loop --all"
    echo "       ./tdd-tcr-refactor-loop -a"
    echo ""
    echo "Examples:"
    echo "  ./tdd-tcr-refactor-loop \"Add a function to validate email addresses\""
    echo "  ./tdd-tcr-refactor-loop --bead factory-gleam-00s"
    echo "  ./tdd-tcr-refactor-loop --all    # Process ALL open beads by priority"
    echo ""
    echo "This script enforces full Red-Green-Refactor TDD:"
    echo "  - RED:     Auditor writes failing test"
    echo "  - GREEN:   Implementer makes it pass (TCR enforced)"
    echo "  - REFACTOR: Architect improves design every $REFACTOR_INTERVAL cycles"
    echo "  - REVIEW:  Final polish at the end"
    echo ""
    echo "Bead mode automatically:"
    echo "  - Updates bead status to 'in_progress' when starting"
    echo "  - Updates bead status to 'closed' on success"
    echo "  - Updates bead status to 'failed' on failure"
    exit 1
}

# Show all-beads summary banner
show_all_beads_banner() {
    local total_beads="$1"

    clear
    echo ""
    echo -e "${MAGENTA}"
    echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•  â•‘'
    echo '  â•‘     â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•   â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘              Processing ALL Open Beads by Priority                 â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
    echo ""
    echo -e "  ${CYAN}Total open beads:${NC} ${BOLD}$total_beads${NC}"
    echo -e "  ${CYAN}Processing order:${NC} P0 (Critical) â†’ P1 (High) â†’ P2 (Medium) â†’ P3 (Low)"
    echo ""
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""
}

# Show final summary of all beads processed
show_all_beads_summary() {
    echo ""
    echo -e "${CYAN}"
    echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•‘'
    echo '  â•‘     â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ•”â•  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•‘'
    echo '  â•‘     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
    echo ""
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${BOLD}ğŸ“Š ALL BEADS PROCESSING COMPLETE${NC}"
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    echo -e "  ${GREEN}âœ“ COMPLETED (${#COMPLETED_BEADS[@]}):${NC}"
    if [ ${#COMPLETED_BEADS[@]} -gt 0 ]; then
        for bead in "${COMPLETED_BEADS[@]}"; do
            echo -e "    ${GREEN}â€¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""

    echo -e "  ${RED}âœ— FAILED (${#FAILED_BEADS[@]}):${NC}"
    if [ ${#FAILED_BEADS[@]} -gt 0 ]; then
        for bead in "${FAILED_BEADS[@]}"; do
            echo -e "    ${RED}â€¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""

    echo -e "  ${YELLOW}â—‹ SKIPPED (${#SKIPPED_BEADS[@]}):${NC}"
    if [ ${#SKIPPED_BEADS[@]} -gt 0 ]; then
        for bead in "${SKIPPED_BEADS[@]}"; do
            echo -e "    ${YELLOW}â€¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
}

# Process a single bead - returns 0 on success, 1 on failure
process_single_bead() {
    # Mark bead as in_progress when starting
    log_info "Marking bead '$CURRENT_BEAD_ID' as in_progress..."
    update_bead_status "$CURRENT_BEAD_ID" "in_progress"

    # Fancy startup banner
    clear
    echo ""
    echo -e "${CYAN}"
    echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—            â•‘'
    echo '  â•‘   â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—           â•‘'
    echo '  â•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•           â•‘'
    echo '  â•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—           â•‘'
    echo '  â•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘      â•šâ•â•   â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•       â•šâ•â•    â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•           â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â•‘'
    echo '  â•‘          â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•        â•‘'
    echo '  â•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘    â•šâ•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘          â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘          â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•   â•šâ•â•           â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘       Adversarial AI-Driven Test-Driven Development               â•‘'
    echo '  â•‘       with TCR Discipline and Architectural Oversight             â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
    echo ""

    # Config summary in a nice box
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${BOLD}Configuration${NC}"
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${CYAN}Language:${NC}        $PROJECT_LANG"
    echo -e "  ${CYAN}Test Command:${NC}    $TEST_CMD"
    echo -e "  ${CYAN}Source:${NC}          $REQUIREMENTS_SOURCE"
    echo -e "  ${CYAN}Max Iterations:${NC}  $MAX_ITERATIONS"
    if [ "$BEAD_MODE" = true ]; then
        echo -e "  ${MAGENTA}Bead ID:${NC}         $CURRENT_BEAD_ID"
        echo -e "  ${MAGENTA}Bead Title:${NC}      $BEAD_TITLE"
        local priority=$(bead_field "$BEAD_JSON" "priority")
        echo -e "  ${MAGENTA}Priority:${NC}        P$priority"
    fi
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    # Disciplines
    echo -e "  ${RED}â—${NC} ${BOLD}RED${NC}       â†’ ${YELLOW}ğŸ” Auditor${NC} writes failing test"
    echo -e "  ${GREEN}â—${NC} ${BOLD}GREEN${NC}     â†’ ${GREEN}ğŸ”§ Implementer${NC} makes it pass (TCR enforced)"
    echo -e "  ${WHITE}â—${NC} ${BOLD}REFACTOR${NC}  â†’ ${WHITE}ğŸ›ï¸  Architect${NC} cleans up every $REFACTOR_INTERVAL cycles"
    echo -e "  ${MAGENTA}â—${NC} ${BOLD}REVIEW${NC}    â†’ ${MAGENTA}ğŸ“‹ Reviewer${NC} final polish"
    echo ""

    # TCR reminder
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${MAGENTA}âŸ³ TCR:${NC} ${BOLD}Test && Commit || Revert${NC} - No broken code survives"
    echo -e "  ${CYAN}ğŸ“¡ Context:${NC} Reasoning flows between agents"
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    # Requirements in a box
    draw_box "REQUIREMENTS" "${YELLOW}"
    echo "$REQUIREMENTS" | while IFS= read -r line; do
        echo -e "  ${DIM}â”‚${NC} $line"
    done
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    # Initialize history file for context passing between agents
    log_info "Initializing session history for context passing..."
    init_history
    append_history "SESSION START" "0" "Requirements: $REQUIREMENTS"

    log_info "Ensuring clean git state..."
    git add -A
    git commit -m "PRE-TDD-TCR-REFACTOR: Savepoint before loop" --no-verify 2>/dev/null || true

    lock_all

    local iteration=1
    local last_impl_result=""
    local impls_since_refactor=0

    while true; do
        log_phase "TDD-TCR-REFACTOR ITERATION $iteration"

        # Phase 1: Auditor writes test (RED)
        if ! run_auditor "$iteration" "$last_impl_result"; then
            echo ""
            echo -e "${GREEN}"
            echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
            echo '  â•‘                                                               â•‘'
            echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘'
            echo '  â•‘   â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•  â•‘'
            echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘'
            echo '  â•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘  â•‘'
            echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•‘'
            echo '  â•‘   â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•  â•‘'
            echo '  â•‘                                                               â•‘'
            echo '  â•‘         ALL REQUIREMENTS IMPLEMENTED AND TESTED               â•‘'
            echo '  â•‘                                                               â•‘'
            echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
            echo -e "${NC}"
            echo ""

            # Final stats box
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo -e "  ${BOLD}ğŸ“Š FINAL STATISTICS${NC}"
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo -e "  ${GREEN}âœ“${NC} TCR Commits:         ${GREEN}${BOLD}$TCR_COMMITS${NC}"
            echo -e "  ${RED}âœ—${NC} TCR Reverts:         ${RED}${BOLD}$TCR_REVERTS${NC}"
            echo -e "  ${WHITE}ğŸ›ï¸${NC} Architect Refactors: ${WHITE}${BOLD}$REFACTOR_COUNT${NC}"
            echo -e "  ${CYAN}ğŸ“${NC} Total Iterations:    ${CYAN}${BOLD}$iteration${NC}"
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo ""

            # Final architect pass before review
            if [ $impls_since_refactor -gt 0 ]; then
                run_architect "$iteration"
            fi

            # Final review
            run_reviewer

            # Mark bead based on reviewer verdict
            if [ "$BEAD_MODE" = true ]; then
                if [ "$REVIEWER_VERDICT" = "passed" ]; then
                    log_success "Marking bead '$CURRENT_BEAD_ID' as closed (acceptance criteria verified)!"
                    local close_msg="Completed via TDD-TCR-REFACTOR loop. Acceptance criteria verified by reviewer. Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS, Refactors: $REFACTOR_COUNT"
                    update_bead_status "$CURRENT_BEAD_ID" "closed" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                elif [ "$REVIEWER_VERDICT" = "failed" ]; then
                    log_error "Marking bead '$CURRENT_BEAD_ID' as failed (acceptance criteria NOT met)"
                    update_bead_status "$CURRENT_BEAD_ID" "failed" "Reviewer determined acceptance criteria were NOT met. Commits: $TCR_COMMITS"
                    FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                else
                    # Unknown verdict - be conservative, mark as needing review
                    log_warning "Marking bead '$CURRENT_BEAD_ID' as needs_review (verdict unclear)"
                    local close_msg="Completed via TDD-TCR-REFACTOR loop but acceptance criteria verdict unclear. Manual review needed. Commits: $TCR_COMMITS"
                    update_bead_status "$CURRENT_BEAD_ID" "needs_review" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE (needs_review)")
                fi
            fi

            unlock_all
            return 0  # Success
        fi

        git add -A
        git commit -m "TEST(tcr-$iteration): New test from auditor" --no-verify 2>/dev/null || true

        log_info "Verifying test is RED (failing)..."

        if run_tests; then
            log_warning "Tests already pass - auditor should write a NEW failing test"
            last_impl_result="All tests passed. Write a new failing test for uncovered requirements."
            iteration=$((iteration + 1))
            continue
        fi

        log_success "Test is RED - proceeding to implementation"

        # Phase 2: Implementer makes it pass (GREEN with TCR)
        if run_implementer "$LAST_TEST_OUTPUT" "$iteration"; then
            last_impl_result="Tests passed and committed. Ready for next test."
            impls_since_refactor=$((impls_since_refactor + 1))

            # Phase 3: Architect refactor check (REFACTOR)
            if [ $impls_since_refactor -ge $REFACTOR_INTERVAL ]; then
                run_architect "$iteration"
                impls_since_refactor=0
            fi
        else
            last_impl_result="Implementation failed after $MAX_IMPL_ATTEMPTS attempts (all reverted). Test may be too ambitious - consider smaller steps."
            log_warning "Continuing despite implementation failure..."
        fi

        iteration=$((iteration + 1))

        if [ $iteration -gt $MAX_ITERATIONS ]; then
            log_phase "MAX ITERATIONS REACHED ($MAX_ITERATIONS)"

            # Final architect pass
            if [ $impls_since_refactor -gt 0 ]; then
                run_architect "$iteration"
            fi

            echo ""
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${GREEN}  FINAL STATISTICS${NC}"
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "  TCR Commits:        ${GREEN}$TCR_COMMITS${NC}"
            echo -e "  TCR Reverts:        ${RED}$TCR_REVERTS${NC}"
            echo -e "  Architect Refactors: ${WHITE}$REFACTOR_COUNT${NC}"
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""

            # Mark bead as closed (max iterations is still a completion, maybe partial)
            if [ "$BEAD_MODE" = true ]; then
                if [ $TCR_COMMITS -gt 0 ]; then
                    log_success "Marking bead '$CURRENT_BEAD_ID' as closed (max iterations reached)"
                    local close_msg="Partial completion via TDD-TCR-REFACTOR loop (max $MAX_ITERATIONS iterations). Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS"
                    update_bead_status "$CURRENT_BEAD_ID" "closed" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE (partial)")
                else
                    log_error "Marking bead '$CURRENT_BEAD_ID' as failed (no successful commits)"
                    update_bead_status "$CURRENT_BEAD_ID" "failed" "No successful commits after $MAX_ITERATIONS iterations"
                    FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                fi
            fi

            unlock_all
            return 0  # Finished (even if partial)
        fi

        log_info "Automatically continuing to iteration $iteration..."
    done
}

#---------------------------------------------------------------------------
# Main Entry Point
#---------------------------------------------------------------------------

main() {
    check_dependencies

    # Handle --all mode: process all open beads
    if [ "$ALL_BEADS_MODE" = true ]; then
        local bead_ids
        bead_ids=$(get_all_open_beads)
        local total_beads=$(echo "$bead_ids" | grep -c . || echo 0)

        if [ "$total_beads" -eq 0 ]; then
            echo "No open beads found in $BEADS_DIR/"
            exit 0
        fi

        show_all_beads_banner "$total_beads"

        local bead_num=0
        while IFS= read -r bead_id; do
            [ -z "$bead_id" ] && continue
            bead_num=$((bead_num + 1))

            echo ""
            echo -e "${MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
            echo -e "${MAGENTA}â•‘  BEAD ${bead_num}/${total_beads}: ${bead_id}${NC}"
            echo -e "${MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""

            # Setup the bead
            if ! setup_bead "$bead_id"; then
                local setup_result=$?
                if [ $setup_result -eq 2 ]; then
                    # Skipped (not open)
                    SKIPPED_BEADS+=("$bead_id: not open")
                else
                    # Error finding bead
                    FAILED_BEADS+=("$bead_id: not found")
                fi
                continue
            fi

            # Process the bead
            if process_single_bead; then
                log_success "Bead '$CURRENT_BEAD_ID' completed!"
            else
                log_error "Bead '$CURRENT_BEAD_ID' failed!"
                FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
            fi

            echo ""
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo -e "  ${CYAN}Progress:${NC} $bead_num / $total_beads beads processed"
            echo -e "${DIM}$(draw_line 'â”€')${NC}"

        done <<< "$bead_ids"

        show_all_beads_summary
        exit 0
    fi

    # Handle single bead or requirements mode
    if [ -z "$REQUIREMENTS" ] && [ "$BEAD_MODE" = false ]; then
        show_usage
    fi

    # Single bead or requirements mode
    if [ "$BEAD_MODE" = true ] && [ -n "$CURRENT_BEAD_ID" ]; then
        process_single_bead
        exit $?
    fi

    # Plain requirements mode (original behavior)
    process_single_bead
    exit $?
}

cleanup() {
    local exit_code=$?
    log_info "Cleaning up locks..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true

    # If bead mode and exiting with error (interrupted or failed), mark bead as failed
    if [ "$BEAD_MODE" = true ] && [ $exit_code -ne 0 ]; then
        log_error "Marking bead '$CURRENT_BEAD_ID' as failed (exit code: $exit_code)"
        update_bead_status "$CURRENT_BEAD_ID" "failed" "Loop terminated with exit code $exit_code. Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS"
    fi

    # Keep history file for debugging, but could add: rm -f "$HISTORY_FILE"
}

trap cleanup EXIT

main
