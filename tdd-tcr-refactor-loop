#!/bin/bash
#
# TDD-TCR-REFACTOR Loop: Full Red-Green-Refactor with Architectural Oversight
#
# Four AI sessions with filesystem-enforced separation:
# - Auditor: writes tests (can't touch src/)
# - Implementer: writes code (can't touch test/) - with TCR enforcement
# - Architect: refactors after every N green cycles (ensures design quality)
# - Reviewer: final cleanup after completion
#
# The REFACTOR step is the key difference:
# - After every REFACTOR_INTERVAL successful implementations
# - Architect reviews and refactors both src/ AND tests
# - Must maintain all passing tests
# - Focuses on: DRY, patterns, idioms, architecture
#
# Usage:
#   ./tdd-tcr-refactor-loop "Feature description or requirements"
#   ./tdd-tcr-refactor-loop --bead <bead-id>      # Use bead issue as requirements
#   ./tdd-tcr-refactor-loop -b <bead-id>          # Short form
#   ./tdd-tcr-refactor-loop --all                 # Process ALL open beads (sorted by priority)
#   ./tdd-tcr-refactor-loop -a                    # Short form for --all
#

set -eo pipefail

#---------------------------------------------------------------------------
# Bead Issue Integration
#---------------------------------------------------------------------------
BEADS_DIR=".beads"
CURRENT_BEAD_ID=""
BEAD_MODE=false
ALL_BEADS_MODE=false
BEAD_JSON=""
BEAD_TITLE=""

# Track results across all beads
declare -a COMPLETED_BEADS=()
declare -a FAILED_BEADS=()
declare -a SKIPPED_BEADS=()

# Find bead by ID in .beads/*.jsonl files
find_bead() {
    local bead_id="$1"
    local bead_json=""

    # Try bd command (if available) for better integration
    # Note: bd show --json returns an array, so extract first element
    if command -v bd >/dev/null 2>&1; then
        bead_json=$(bd show "$bead_id" --json 2>/dev/null | jq '.[0]' 2>/dev/null)
        if [ -n "$bead_json" ] && [ "$bead_json" != "null" ]; then
            echo "$bead_json"
            return 0
        fi
    fi

    # Fallback to manual search
    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        bead_json=$(grep -h "\"id\":\"$bead_id\"" "$jsonl_file" 2>/dev/null | head -1)
        if [ -n "$bead_json" ]; then
            echo "$bead_json"
            return 0
        fi
    done
    return 1
}

# Get all open beads sorted by priority (P0 first, then P1, P2, etc.)
# Uses bv --robot-next for graph-aware priority (respects blockers, PageRank, etc.)
get_all_open_beads() {
    local all_beads=""

    # Try bv --robot-triage first (best: graph-aware, respects blockers)
    if command -v bv >/dev/null 2>&1; then
        # Use --recipe actionable to get only ready-to-work beads
        bv --recipe actionable --robot-plan 2>/dev/null | \
            jq -r '.plan.tracks[].items[].id' 2>/dev/null && return 0
    fi

    # Fallback to bd ready command
    if command -v bd >/dev/null 2>&1; then
        bd ready --json 2>/dev/null | jq -r '.[].id' 2>/dev/null && return 0
    fi

    # Final fallback: manual search
    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        # Get all lines with status "open", extract id and priority for sorting
        while IFS= read -r line; do
            if echo "$line" | jq -e 'select(.status == "open")' >/dev/null 2>&1; then
                local id=$(echo "$line" | jq -r '.id')
                local priority=$(echo "$line" | jq -r '.priority // 99')
                echo "$priority $id"
            fi
        done < "$jsonl_file"
    done | sort -n | cut -d' ' -f2
}

# Count open beads
count_open_beads() {
    get_all_open_beads | wc -l
}

# Extract field from bead JSON
bead_field() {
    local json="$1"
    local field="$2"
    echo "$json" | jq -r ".$field // empty" 2>/dev/null
}

# Update bead status in the jsonl file
update_bead_status() {
    local bead_id="$1"
    local new_status="$2"
    local close_reason="${3:-}"

    # Note: bv is read-only (graph analysis), use bd for updates
    # Try bd command first (if available)
    if command -v bd >/dev/null 2>&1; then
        case "$new_status" in
            closed)
                bd close "$bead_id" ${close_reason:+--reason "$close_reason"} 2>/dev/null && return 0
                ;;
            in_progress|in-progress)
                bd update "$bead_id" --status in-progress 2>/dev/null && return 0
                ;;
            failed)
                # Add comment about failure, keep open for manual review
                if [ -n "$close_reason" ]; then
                    bd comment "$bead_id" "AUTOMATED FAILURE: $close_reason" 2>/dev/null || true
                fi
                bd update "$bead_id" --status open 2>/dev/null && return 0
                ;;
            *)
                bd update "$bead_id" --status "$new_status" 2>/dev/null && return 0
                ;;
        esac
    fi

    # Fallback to manual update
    for jsonl_file in "$BEADS_DIR"/*.jsonl; do
        [ -f "$jsonl_file" ] || continue
        if grep -q "\"id\":\"$bead_id\"" "$jsonl_file" 2>/dev/null; then
            local tmp_file=$(mktemp)
            local now=$(date -Iseconds)

            while IFS= read -r line; do
                if echo "$line" | grep -q "\"id\":\"$bead_id\""; then
                    # Update status
                    line=$(echo "$line" | jq -c ".status = \"$new_status\" | .updated_at = \"$now\"")
                    # Add close fields if closing
                    if [ "$new_status" = "closed" ] && [ -n "$close_reason" ]; then
                        line=$(echo "$line" | jq -c ".closed_at = \"$now\" | .close_reason = \"$close_reason\"")
                    fi
                fi
                echo "$line"
            done < "$jsonl_file" > "$tmp_file"

            mv "$tmp_file" "$jsonl_file"
            return 0
        fi
    done
    return 1
}

# Build requirements string from bead fields
build_requirements_from_bead() {
    local bead_json="$1"
    local title=$(bead_field "$bead_json" "title")
    local description=$(bead_field "$bead_json" "description")
    local acceptance=$(bead_field "$bead_json" "acceptance_criteria")

    cat <<EOF
## $title

$description

### Acceptance Criteria
$acceptance
EOF
}

# Create a new bead from architect findings with proper dependencies and scope
create_bead_from_architect() {
    local title="$1"
    local description="$2"
    local priority="${3:-2}"  # Default to P2 (medium)
    local current_bead_id="${4:-}"  # Link to current bead if available

    # Enhance description with context and make it actionable
    local enhanced_desc="$description

## Context
- Identified during refactoring in TDD-TCR loop
- Current codebase state allows tests to pass but has technical debt
- Should be addressed to maintain code quality

## Scope
This is a FOCUSED refactoring task. Should be completable in one TDD-TCR session.
- Modify only the specific area mentioned
- Ensure all existing tests continue to pass
- Add tests if behavior changes"

    if [ -n "$current_bead_id" ]; then
        enhanced_desc="$enhanced_desc

## Related Work
- Discovered while working on: $current_bead_id"
    fi

    # Try bd command first
    if command -v bd >/dev/null 2>&1; then
        local create_args=(
            --title "$title"
            --description "$enhanced_desc"
            --priority "$priority"
            --tags "architect-generated,code-smell,technical-debt,refactoring"
        )

        # Link to current bead if available
        if [ -n "$current_bead_id" ]; then
            create_args+=(--related-to "$current_bead_id")
        fi

        local new_bead_id=$(bd create "${create_args[@]}" --json 2>/dev/null | jq -r '.id' 2>/dev/null)

        if [ -n "$new_bead_id" ] && [ "$new_bead_id" != "null" ]; then
            log_success "Created bead $new_bead_id: $title"
            BEADS_CREATED_BY_ARCHITECT=$((BEADS_CREATED_BY_ARCHITECT + 1))
            return 0
        fi
    fi

    # Fallback: create manually in .beads/technical-debt.jsonl
    mkdir -p "$BEADS_DIR"
    local bead_file="$BEADS_DIR/technical-debt.jsonl"
    local new_id="arch-$(date +%s)-$(( RANDOM % 1000 ))"
    local now=$(date -Iseconds)

    local bead_json=$(jq -n \
        --arg id "$new_id" \
        --arg title "$title" \
        --arg desc "$enhanced_desc" \
        --arg pri "$priority" \
        --arg now "$now" \
        --arg parent "$current_bead_id" \
        '{
            id: $id,
            title: $title,
            description: $desc,
            priority: ($pri | tonumber),
            status: "open",
            tags: ["architect-generated", "code-smell", "technical-debt", "refactoring"],
            created_at: $now,
            updated_at: $now,
            created_by: "tdd-tcr-refactor-loop",
            parent_bead: (if $parent != "" then $parent else null end)
        }')

    echo "$bead_json" >> "$bead_file"
    log_success "Created bead $new_id: $title (in $bead_file)"
    BEADS_CREATED_BY_ARCHITECT=$((BEADS_CREATED_BY_ARCHITECT + 1))
    return 0
}

# Parse architect output and create beads from CREATE_BEAD directives
parse_and_create_beads() {
    local architect_output="$1"
    local in_bead=false
    local bead_title=""
    local bead_description=""
    local bead_priority="2"

    while IFS= read -r line; do
        if [[ "$line" =~ ^CREATE_BEAD:\ (.+)$ ]]; then
            in_bead=true
            bead_title="${BASH_REMATCH[1]}"
            bead_description=""
            bead_priority="2"
        elif [[ "$line" =~ ^DESCRIPTION:\ (.+)$ ]] && [ "$in_bead" = true ]; then
            bead_description="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^PRIORITY:\ ([0-3])$ ]] && [ "$in_bead" = true ]; then
            bead_priority="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^---$ ]] && [ "$in_bead" = true ]; then
            # End of bead definition - create it
            if [ -n "$bead_title" ] && [ -n "$bead_description" ]; then
                create_bead_from_architect "$bead_title" "$bead_description" "$bead_priority" "$CURRENT_BEAD_ID"
            fi
            in_bead=false
            bead_title=""
            bead_description=""
            bead_priority="2"
        elif [ "$in_bead" = true ] && [[ "$line" =~ ^DESCRIPTION: ]]; then
            # Continue multi-line description
            bead_description="$bead_description $line"
        fi
    done <<< "$architect_output"
}

# Parse --bead/-b argument
parse_bead_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --bead|-b)
                BEAD_MODE=true
                CURRENT_BEAD_ID="$2"
                shift 2
                ;;
            *)
                # Not a bead arg, return remaining args
                echo "$@"
                return
                ;;
        esac
    done
}

# Show bv triage summary (if available)
show_bv_triage() {
    if command -v bv >/dev/null 2>&1; then
        log_info "Getting graph-aware triage from bv..."
        local triage_json=$(bv --robot-triage 2>/dev/null)
        if [ -n "$triage_json" ]; then
            echo ""
            echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${CYAN}  BV GRAPH TRIAGE${NC}"
            echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo "$triage_json" | jq -r '.triage.quick_ref |
                "  Open: \(.open_count)\n  Actionable: \(.actionable_count)\n  Blocked: \(.blocked_count)\n  In Progress: \(.in_progress_count)"' 2>/dev/null || echo "  (triage data unavailable)"
            echo ""
            echo -e "${BOLD}Top Recommendation:${NC}"
            echo "$triage_json" | jq -r '.triage.quick_ref.top_picks[0] |
                "  ID: \(.id)\n  Title: \(.title)\n  Score: \(.score)\n  Unblocks: \(.unblocks) issues"' 2>/dev/null || echo "  (no recommendations)"
            echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""
        fi
    fi
}

# Dependency checks
check_dependencies() {
    local missing=()
    command -v claude >/dev/null 2>&1 || missing+=("claude")
    command -v uuidgen >/dev/null 2>&1 || missing+=("uuidgen")
    command -v jq >/dev/null 2>&1 || missing+=("jq")
    git rev-parse --git-dir >/dev/null 2>&1 || missing+=("git (not in a repository)")

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Missing dependencies: ${missing[*]}"
        exit 1
    fi

    # Optional tools (warn but don't fail)
    local optional_missing=()
    command -v bv >/dev/null 2>&1 || optional_missing+=("bv (graph-aware triage)")
    command -v bd >/dev/null 2>&1 || optional_missing+=("bd (bead management)")
    command -v codanna >/dev/null 2>&1 || optional_missing+=("codanna (semantic search)")

    if [ ${#optional_missing[@]} -gt 0 ]; then
        echo -e "${YELLOW}Optional tools not found: ${optional_missing[*]}${NC}"
        echo -e "${DIM}Install from: https://github.com/Dicklesworthstone/beads_viewer${NC}"
        echo -e "${DIM}            https://github.com/bartolli/codanna${NC}"
        echo ""
    fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
NC='\033[0m' # No Color

# Background colors
BG_RED='\033[41m'
BG_GREEN='\033[42m'
BG_YELLOW='\033[43m'
BG_BLUE='\033[44m'
BG_MAGENTA='\033[45m'
BG_CYAN='\033[46m'
BG_WHITE='\033[47m'

# Box drawing characters
BOX_TL='â•”'
BOX_TR='â•—'
BOX_BL='â•š'
BOX_BR='â•'
BOX_H='â•'
BOX_V='â•‘'
BOX_LT='â• '
BOX_RT='â•£'

# Progress indicators
SPINNER_CHARS='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
PROGRESS_FULL='â–ˆ'
PROGRESS_EMPTY='â–‘'

# Configuration
SRC_DIR="src"
TEST_DIR="test"
MAX_IMPL_ATTEMPTS=3
MAX_ITERATIONS=15
REFACTOR_INTERVAL=3  # Run architect every N successful implementations
PAUSE_BETWEEN_BEADS=5  # seconds between beads in --all mode
ESCALATION_THRESHOLD=3  # Escalate to Sonnet after N consecutive failures
AI_LEARNING_DIR=".factory/learnings"
AI_LEARNING_FILE=".factory/learnings/session-learnings.md"

# Handle requirements from bead, file, or argument
REQUIREMENTS=""
REQUIREMENTS_SOURCE=""

# Setup a single bead for processing
setup_bead() {
    local bead_id="$1"
    CURRENT_BEAD_ID="$bead_id"
    BEAD_MODE=true

    BEAD_JSON=$(find_bead "$CURRENT_BEAD_ID")
    if [ -z "$BEAD_JSON" ]; then
        echo "Error: Bead '$CURRENT_BEAD_ID' not found in $BEADS_DIR/"
        return 1
    fi

    BEAD_STATUS=$(bead_field "$BEAD_JSON" "status")
    if [ "$BEAD_STATUS" != "open" ]; then
        echo "Skipping bead '$CURRENT_BEAD_ID' - status is '$BEAD_STATUS' (not 'open')"
        return 2
    fi

    REQUIREMENTS=$(build_requirements_from_bead "$BEAD_JSON")
    REQUIREMENTS_SOURCE="bead: $CURRENT_BEAD_ID"
    BEAD_TITLE=$(bead_field "$BEAD_JSON" "title")

    # Reset statistics for this bead
    TCR_COMMITS=0
    TCR_REVERTS=0
    REFACTOR_COUNT=0
    SUCCESSFUL_IMPLS=0

    return 0
}

# Check for --all mode first
if [ "$1" = "--all" ] || [ "$1" = "-a" ]; then
    ALL_BEADS_MODE=true
    BEAD_MODE=true
# Check for single bead mode
elif [ "$1" = "--bead" ] || [ "$1" = "-b" ]; then
    BEAD_MODE=true
    CURRENT_BEAD_ID="$2"

    if [ -z "$CURRENT_BEAD_ID" ]; then
        echo "Error: --bead requires a bead ID"
        exit 1
    fi

    BEAD_JSON=$(find_bead "$CURRENT_BEAD_ID")
    if [ -z "$BEAD_JSON" ]; then
        echo "Error: Bead '$CURRENT_BEAD_ID' not found in $BEADS_DIR/"
        exit 1
    fi

    BEAD_STATUS=$(bead_field "$BEAD_JSON" "status")
    if [ "$BEAD_STATUS" != "open" ]; then
        echo "Warning: Bead '$CURRENT_BEAD_ID' has status '$BEAD_STATUS' (not 'open')"
        read -p "Continue anyway? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi

    REQUIREMENTS=$(build_requirements_from_bead "$BEAD_JSON")
    REQUIREMENTS_SOURCE="bead: $CURRENT_BEAD_ID"
    BEAD_TITLE=$(bead_field "$BEAD_JSON" "title")
elif [ -f "$1" ]; then
    REQUIREMENTS=$(cat "$1")
    REQUIREMENTS_SOURCE="file: $1"
else
    REQUIREMENTS="$1"
    REQUIREMENTS_SOURCE="argument"
fi

# Detect language from project files
detect_language() {
    if [ -f "gleam.toml" ]; then
        echo "gleam"
    elif [ -f "go.mod" ]; then
        echo "go"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
        echo "python"
    else
        echo "unknown"
    fi
}

PROJECT_LANG=$(detect_language)
TEST_CMD="gleam test"
case "$PROJECT_LANG" in
    gleam) TEST_CMD="gleam test" ;;
    go) TEST_CMD="go test ./..." ;;
    rust) TEST_CMD="cargo test" ;;
    python) TEST_CMD="pytest" ;;
esac

# Statistics
TCR_COMMITS=0
TCR_REVERTS=0
REFACTOR_COUNT=0
SUCCESSFUL_IMPLS=0
CONSECUTIVE_FAILURES=0
BEADS_CREATED_BY_ARCHITECT=0

# Context passing between agents
HISTORY_FILE=".tdd-history.md"
LAST_AUDITOR_REASONING=""
LAST_IMPL_REASONING=""

# Initialize AI learning system
init_ai_learning() {
    mkdir -p "$AI_LEARNING_DIR"

    if [ ! -f "$AI_LEARNING_FILE" ]; then
        cat > "$AI_LEARNING_FILE" << 'LEARNINGEOF'
# AI Session Learnings

This file accumulates knowledge across TDD-TCR-REFACTOR sessions to help AI agents
learn from past successes and failures.

## Purpose
- Document what works well in this codebase
- Capture patterns that should be reused
- Record pitfalls to avoid
- Share language-specific idioms discovered

## Format
Each session appends its learnings below, tagged with timestamp and bead context.

---

LEARNINGEOF
    fi
}

# Load AI learnings to provide context to agents
load_ai_learnings() {
    if [ -f "$AI_LEARNING_FILE" ]; then
        tail -n 200 "$AI_LEARNING_FILE" 2>/dev/null || echo "(no learnings yet)"
    else
        echo "(no learnings yet)"
    fi
}

# Save AI learnings from session
save_ai_learning() {
    local content="$1"
    local timestamp=$(date -Iseconds)
    local bead_info=""

    if [ "$BEAD_MODE" = true ]; then
        bead_info="Bead: $CURRENT_BEAD_ID ($BEAD_TITLE)"
    fi

    {
        echo ""
        echo "---"
        echo ""
        echo "## Session: $timestamp"
        [ -n "$bead_info" ] && echo "$bead_info"
        echo "Stats: $TCR_COMMITS commits, $TCR_REVERTS reverts, $REFACTOR_COUNT refactors, $BEADS_CREATED_BY_ARCHITECT new beads"
        echo ""
        echo "$content"
    } >> "$AI_LEARNING_FILE"
}

# Initialize history file
init_history() {
    cat > "$HISTORY_FILE" << 'HISTEOF'
# TDD-TCR-REFACTOR Session History

This file tracks the reasoning from each agent to provide context to subsequent agents.

---

HISTEOF
}

# Append to history
append_history() {
    local role="$1"
    local iteration="$2"
    local content="$3"

    echo "" >> "$HISTORY_FILE"
    echo "## Iteration $iteration - $role" >> "$HISTORY_FILE"
    echo "" >> "$HISTORY_FILE"
    echo "$content" >> "$HISTORY_FILE"
    echo "" >> "$HISTORY_FILE"
    echo "---" >> "$HISTORY_FILE"
}

# Get recent history (last N entries, trimmed for context window)
get_recent_history() {
    local max_lines="${1:-100}"
    tail -n "$max_lines" "$HISTORY_FILE" 2>/dev/null || echo "(no history yet)"
}

#---------------------------------------------------------------------------
# Utility functions
#---------------------------------------------------------------------------

# Get terminal width
get_term_width() {
    tput cols 2>/dev/null || echo 80
}

# Draw a horizontal line (handles multi-byte UTF-8 characters)
draw_line() {
    local char="${1:-â•}"
    local width="${2:-$(get_term_width)}"
    local result=""
    for ((i=0; i<width; i++)); do
        result+="$char"
    done
    printf '%s' "$result"
}

# Center text (pads both left and right to fill width)
center_text() {
    local text="$1"
    local width="${2:-$(get_term_width)}"
    local text_len=${#text}
    local left_pad=$(( (width - text_len) / 2 ))
    local right_pad=$(( width - text_len - left_pad ))
    printf '%*s%s%*s' "$left_pad" '' "$text" "$right_pad" ''
}

# Draw fancy box
draw_box() {
    local title="$1"
    local color="$2"
    local width=$(get_term_width)
    local inner_width=$((width - 4))

    echo ""
    echo -e "${color}â•”$(draw_line 'â•' $((width-2)))â•—${NC}"
    echo -e "${color}â•‘$(center_text "$title" $((width-2)))â•‘${NC}"
    echo -e "${color}â•š$(draw_line 'â•' $((width-2)))â•${NC}"
    echo ""
}

# Draw status dashboard
draw_dashboard() {
    local iteration="$1"
    local width=$(get_term_width)

    echo -e "${DIM}$(draw_line 'â”€' $width)${NC}"
    echo -e "${BOLD}  ğŸ“Š DASHBOARD${NC}  â”‚  Iter: ${CYAN}$iteration${NC}  â”‚  âœ“ ${GREEN}$TCR_COMMITS${NC}  â”‚  âœ— ${RED}$TCR_REVERTS${NC}  â”‚  ğŸ›ï¸ ${WHITE}$REFACTOR_COUNT${NC}  â”‚  ğŸ”§ ${YELLOW}$BEADS_CREATED_BY_ARCHITECT${NC}  â”‚  âš ï¸ ${MAGENTA}$CONSECUTIVE_FAILURES${NC}"
    echo -e "${DIM}$(draw_line 'â”€' $width)${NC}"
}

# Progress bar
draw_progress() {
    local current="$1"
    local total="$2"
    local width=30
    local filled=$((current * width / total))
    local empty=$((width - filled))
    local percent=$((current * 100 / total))

    printf "${CYAN}["
    printf '%*s' "$filled" '' | tr ' ' "$PROGRESS_FULL"
    printf '%*s' "$empty" '' | tr ' ' "$PROGRESS_EMPTY"
    printf "] ${WHITE}%3d%%${NC}" "$percent"
}

log_phase() {
    local title="$1"
    draw_box "$title" "${BLUE}"
}

log_auditor() {
    echo ""
    echo -e "${YELLOW}â”Œ$(draw_line 'â”€' 58)â”${NC}"
    echo -e "${YELLOW}â”‚  ğŸ” AUDITOR: ${BOLD}$1${NC}${YELLOW}$(printf '%*s' $((44 - ${#1})) '')â”‚${NC}"
    echo -e "${YELLOW}â””$(draw_line 'â”€' 58)â”˜${NC}"
    echo ""
}

log_implementer() {
    echo ""
    echo -e "${GREEN}â”Œ$(draw_line 'â”€' 58)â”${NC}"
    echo -e "${GREEN}â”‚  ğŸ”§ IMPLEMENTER: ${BOLD}$1${NC}${GREEN}$(printf '%*s' $((40 - ${#1})) '')â”‚${NC}"
    echo -e "${GREEN}â””$(draw_line 'â”€' 58)â”˜${NC}"
    echo ""
}

log_architect() {
    echo ""
    echo -e "${WHITE}${BOLD}â•”$(draw_line 'â•' 58)â•—${NC}"
    echo -e "${WHITE}${BOLD}â•‘  ğŸ›ï¸  ARCHITECT: $1$(printf '%*s' $((40 - ${#1})) '')â•‘${NC}"
    echo -e "${WHITE}${BOLD}â•š$(draw_line 'â•' 58)â•${NC}"
    echo ""
}

log_reviewer() {
    echo ""
    echo -e "${MAGENTA}â•”$(draw_line 'â•' 58)â•—${NC}"
    echo -e "${MAGENTA}â•‘  ğŸ“‹ REVIEWER: ${BOLD}$1${NC}${MAGENTA}$(printf '%*s' $((42 - ${#1})) '')â•‘${NC}"
    echo -e "${MAGENTA}â•š$(draw_line 'â•' 58)â•${NC}"
    echo ""
}

log_info() {
    echo -e "  ${CYAN}â†’${NC} $1"
}

log_success() {
    echo -e "  ${GREEN}âœ“${NC} ${GREEN}$1${NC}"
}

log_warning() {
    echo -e "  ${YELLOW}âš ${NC} ${YELLOW}$1${NC}"
}

log_error() {
    echo -e "  ${RED}âœ—${NC} ${RED}$1${NC}"
}

log_tcr() {
    echo -e "  ${MAGENTA}âŸ³${NC} ${BOLD}TCR:${NC} $1"
}

log_tdd_phase() {
    local phase="$1"
    local color="$2"
    local emoji="$3"
    echo -e "\n  ${color}${emoji} ${BOLD}${phase}${NC}"
}

# Show TDD cycle indicator
show_tdd_cycle() {
    local phase="$1"  # red, green, refactor
    local r_color="${DIM}"
    local g_color="${DIM}"
    local f_color="${DIM}"

    case "$phase" in
        red) r_color="${RED}${BOLD}" ;;
        green) g_color="${GREEN}${BOLD}" ;;
        refactor) f_color="${WHITE}${BOLD}" ;;
    esac

    echo -e "\n  TDD Cycle: [${r_color}RED${NC}] â†’ [${g_color}GREEN${NC}] â†’ [${f_color}REFACTOR${NC}]"
}

#---------------------------------------------------------------------------
# Lock management
#---------------------------------------------------------------------------

lock_all() {
    log_info "Locking all source and test files..."
    chmod -R a-w "$SRC_DIR/" 2>/dev/null || true
    chmod -R a-w "$TEST_DIR/" 2>/dev/null || true
}

unlock_src() {
    log_info "Unlocking src/ for implementer..."
    chmod -R u+w "$SRC_DIR/"
}

lock_src() {
    log_info "Locking src/..."
    chmod -R a-w "$SRC_DIR/"
}

unlock_tests() {
    log_info "Unlocking test/ for auditor..."
    chmod -R u+w "$TEST_DIR/"
}

lock_tests() {
    log_info "Locking test/..."
    chmod -R a-w "$TEST_DIR/"
}

unlock_all() {
    log_info "Unlocking all files..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true
}

#---------------------------------------------------------------------------
# Git/TCR operations
#---------------------------------------------------------------------------

tcr_commit() {
    local iteration="$1"
    local message="$2"

    log_tcr "Tests PASSED - Committing changes..."
    git add -A
    git commit -m "PASS(tcr-$iteration): $message" --no-verify 2>/dev/null || true
    TCR_COMMITS=$((TCR_COMMITS + 1))
    log_success "TCR Commit #$TCR_COMMITS"
}

tcr_revert() {
    local iteration="$1"

    log_tcr "Tests FAILED - Reverting implementation changes..."
    git checkout HEAD -- "$SRC_DIR/" 2>/dev/null || true
    git clean -fd "$SRC_DIR/" 2>/dev/null || true
    TCR_REVERTS=$((TCR_REVERTS + 1))
    log_error "TCR Revert #$TCR_REVERTS - Implementation discarded"
}

#---------------------------------------------------------------------------
# Test execution
#---------------------------------------------------------------------------

# Run tests and capture output. Sets LAST_TEST_OUTPUT and returns exit code.
run_tests() {
    log_info "Running tests ($TEST_CMD)..."
    LAST_TEST_OUTPUT=$($TEST_CMD 2>&1) && return 0 || return 1
}

# Run tests silently, just for pass/fail check
run_tests_quiet() {
    $TEST_CMD >/dev/null 2>&1
}

#---------------------------------------------------------------------------
# AI Prompts
#---------------------------------------------------------------------------

auditor_prompt() {
    local iteration="$1"
    local last_impl_result="$2"

    cat <<EOF
<ctx lang="$PROJECT_LANG" iter="$iteration" cmd="$TEST_CMD"/>
<req>$REQUIREMENTS</req>
$([ -n "$last_impl_result" ] && echo "<last>$last_impl_result</last>")

AUDITOR: Write 1 failing test in test/. Be concise.

RULES: Only test/, ONE test, must FAIL initially.
If requirements complete: output REQUIREMENTS_COMPLETE

Do: Read src/ + test/, write minimal test, use /gleam-code-generator skill.
EOF
}

implementer_prompt() {
    local test_output="$1"
    local attempt="$2"
    local auditor_reasoning="$3"
    local ai_learnings="$4"
    local is_escalated="${5:-false}"

    cat <<EOF
<ctx lang="$PROJECT_LANG" cmd="$TEST_CMD" attempt="$attempt/$MAX_IMPL_ATTEMPTS"/>
$([ "$is_escalated" = "true" ] && echo "<escalated failures=\"$CONSECUTIVE_FAILURES\"/>")
<test_output>$test_output</test_output>

IMPLEMENTER: Make test pass. TCR enforced (FAIL=REVERT). Be minimal.

RULES: Only src/, MINIMUM code, no extras.
Do: Read test, implement exactly what's needed, use /gleam-code-generator skill.
EOF
}

architect_prompt() {
    local iteration="$1"
    local session_history="$2"
    local ai_learnings="$3"

    cat <<EOF
<ctx lang="$PROJECT_LANG" cmd="$TEST_CMD" iter="$iteration" commits="$TCR_COMMITS" reverts="$TCR_REVERTS"/>
<req>$REQUIREMENTS</req>

ARCHITECT: Refactor. Delete > Simplify > Extract. Tests MUST pass.

CUPID: Composable, Unix-philosophy, Predictable, Idiomatic, Domain-based.
Max 30 lines/fn. No unused code. Pure functions in core.

Do: Read src/+test/, refactor ruthlessly, run tests, use /gleam-code-generator skill.

For code smells output:
CREATE_BEAD: <title>
DESCRIPTION: <issue>
PRIORITY: 0-3
---
EOF
}

reviewer_prompt() {
    local acceptance=""
    if [ "$BEAD_MODE" = true ]; then
        acceptance=$(bead_field "$BEAD_JSON" "acceptance_criteria")
    fi

    cat <<EOF
<ctx lang="$PROJECT_LANG" cmd="$TEST_CMD" commits="$TCR_COMMITS" reverts="$TCR_REVERTS"/>
<req>$REQUIREMENTS</req>
$([ -n "$acceptance" ] && echo "<acceptance bead=\"$CURRENT_BEAD_ID\">$acceptance</acceptance>")

REVIEWER: Final check. Run tests. Verify acceptance criteria.

Output REQUIRED:
ACCEPTANCE_CRITERIA_MET: true|false
<verify criterion="X" met="true|false" evidence="file:line"/>

Brief learnings (50 words max) for ## AI LEARNINGS section.
EOF
}

#---------------------------------------------------------------------------
# AI Session Runners
#---------------------------------------------------------------------------

run_auditor() {
    local iteration="$1"
    local last_result="$2"
    local prompt

    show_tdd_cycle "red"
    log_auditor "Writing failing test (Iteration $iteration)"
    draw_dashboard "$iteration"

    lock_src
    unlock_tests

    prompt=$(auditor_prompt "$iteration" "$last_result")

    log_info "Invoking auditor AI (new session, haiku-4.5)..."
    AUDITOR_SESSION_ID=$(uuidgen)
    auditor_output=$(claude -p \
        --model haiku \
        --session-id "$AUDITOR_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
        --append-system-prompt "You are the AUDITOR. You may ONLY modify files in test/. Any attempt to modify src/ will fail. Focus on writing ONE failing test that drives good design. If all requirements are met, output REQUIREMENTS_COMPLETE. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
        "/gleam-code-generator $prompt" 2>&1 </dev/null)

    echo "$auditor_output"

    # Save auditor's reasoning to history for implementer
    LAST_AUDITOR_REASONING="$auditor_output"
    append_history "AUDITOR" "$iteration" "$auditor_output"

    lock_tests

    if echo "$auditor_output" | grep -q "REQUIREMENTS_COMPLETE"; then
        log_success "Auditor reports all requirements are complete!"
        return 1
    fi

    log_success "Auditor phase complete"
    return 0
}

run_implementer() {
    local test_output="$1"
    local iteration="$2"
    local attempt=1

    show_tdd_cycle "green"
    log_implementer "Making test pass (Iteration $iteration)"
    draw_dashboard "$iteration"

    # Load AI learnings
    local ai_learnings
    ai_learnings=$(load_ai_learnings)

    # Determine if we should escalate to Sonnet
    local use_escalation=false
    local model="haiku"
    if [ $CONSECUTIVE_FAILURES -ge $ESCALATION_THRESHOLD ]; then
        use_escalation=true
        model="sonnet"
        log_warning "Escalating to Sonnet model after $CONSECUTIVE_FAILURES consecutive failures"
    fi

    while [ $attempt -le $MAX_IMPL_ATTEMPTS ]; do
        log_info "Implementation attempt $attempt of $MAX_IMPL_ATTEMPTS $(draw_progress $attempt $MAX_IMPL_ATTEMPTS)"

        lock_tests
        unlock_src

        log_tcr "Recording pre-implementation state..."

        # Pass auditor's reasoning and AI learnings to implementer
        prompt=$(implementer_prompt "$test_output" "$attempt" "$LAST_AUDITOR_REASONING" "$ai_learnings" "$use_escalation")

        log_info "Invoking implementer AI (new session, $model)..."
        IMPLEMENTER_SESSION_ID=$(uuidgen)
        impl_output=$(claude -p \
            --model "$model" \
            --session-id "$IMPLEMENTER_SESSION_ID" \
            --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
            --append-system-prompt "You are the IMPLEMENTER under TCR discipline. You may ONLY modify files in src/. If tests fail, your changes will be REVERTED. Write MINIMUM code to pass the test. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
            "/gleam-code-generator $prompt" 2>&1 </dev/null)

        echo "$impl_output"

        # Save implementer's reasoning to history
        append_history "IMPLEMENTER" "$iteration (attempt $attempt)" "$impl_output"

        lock_src

        log_phase "TCR CHECK"
        log_info "Running tests to determine commit or revert..."

        if run_tests; then
            tcr_commit "$iteration" "Implemented for iteration $iteration"
            log_success "Tests pass! Implementation committed."
            SUCCESSFUL_IMPLS=$((SUCCESSFUL_IMPLS + 1))
            CONSECUTIVE_FAILURES=0  # Reset failure counter on success
            return 0
        else
            tcr_revert "$iteration"
            append_history "TCR" "$iteration" "REVERTED - tests failed"
            test_output="$LAST_TEST_OUTPUT"
            attempt=$((attempt + 1))
            CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))

            if [ $attempt -le $MAX_IMPL_ATTEMPTS ]; then
                log_warning "Trying again with fresh implementation..."
            fi
        fi
    done

    log_error "Implementer failed after $MAX_IMPL_ATTEMPTS attempts (all reverted)"
    return 1
}

run_architect() {
    local iteration="$1"

    show_tdd_cycle "refactor"
    log_architect "REFACTOR PHASE (after $SUCCESSFUL_IMPLS green cycles)"
    draw_dashboard "$iteration"

    unlock_all

    # Get session history and AI learnings for architect context
    local session_history ai_learnings
    session_history=$(get_recent_history 200)
    ai_learnings=$(load_ai_learnings)

    prompt=$(architect_prompt "$iteration" "$session_history" "$ai_learnings")

    log_info "Invoking architect AI (new session, sonnet for deeper analysis)..."
    ARCHITECT_SESSION_ID=$(uuidgen)
    architect_output=$(claude -p \
        --model sonnet \
        --session-id "$ARCHITECT_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
        --append-system-prompt "You are the ARCHITECT. You may modify both src/ and test/. Your job is to REFACTOR the code for quality and maintainability. ALL TESTS MUST STILL PASS. Focus on CUPID, code minimization, and idiomatic patterns. Every line must earn its place. SCAN for code smells and CREATE_BEAD for issues you find. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
        "/gleam-code-generator $prompt" 2>&1 </dev/null)

    echo "$architect_output"

    # Parse architect output for bead creation requests
    log_info "Scanning architect output for code smell beads..."
    parse_and_create_beads "$architect_output"

    # Save architect's reasoning to history
    append_history "ARCHITECT" "$iteration" "$architect_output"

    log_info "Verifying tests still pass after refactoring..."
    if run_tests; then
        log_success "Architect refactoring complete - all tests still pass"
        git add -A
        git commit -m "REFACTOR(architect-$REFACTOR_COUNT): Architectural improvements" --no-verify 2>/dev/null || true
        REFACTOR_COUNT=$((REFACTOR_COUNT + 1))
    else
        log_error "Architect broke tests! Reverting all changes..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        git clean -fd "$SRC_DIR/" "$TEST_DIR/" 2>/dev/null || true
        append_history "ARCHITECT" "$iteration" "REVERTED - tests broke after refactoring"
        log_warning "Architect changes reverted - tests must pass"
    fi

    lock_all
}

REVIEWER_VERDICT=""
REVIEWER_OUTPUT=""

run_reviewer() {
    log_reviewer "Final Production Polish"
    draw_dashboard "FINAL"

    unlock_all

    prompt=$(reviewer_prompt)

    log_info "Invoking reviewer AI (new session, haiku-4.5)..."
    REVIEWER_SESSION_ID=$(uuidgen)
    REVIEWER_OUTPUT=$(claude -p \
        --model haiku \
        --session-id "$REVIEWER_SESSION_ID" \
        --allowedTools "Read Write Edit Glob Grep Bash(gleam:*) Skill" \
        --append-system-prompt "You are the REVIEWER doing final review. You may modify both src/ and test/. All tests MUST pass. Focus on production readiness and polish. You MUST output ACCEPTANCE_CRITERIA_MET: true or ACCEPTANCE_CRITERIA_MET: false in your response. IMPORTANT: Use /gleam-code-generator skill for all Gleam code generation." \
        "/gleam-code-generator $prompt" 2>&1 </dev/null)

    echo "$REVIEWER_OUTPUT"

    # Extract acceptance criteria verdict
    if echo "$REVIEWER_OUTPUT" | grep -q "ACCEPTANCE_CRITERIA_MET: true"; then
        REVIEWER_VERDICT="passed"
        log_success "Reviewer confirms: ACCEPTANCE CRITERIA MET"
    elif echo "$REVIEWER_OUTPUT" | grep -q "ACCEPTANCE_CRITERIA_MET: false"; then
        REVIEWER_VERDICT="failed"
        log_error "Reviewer reports: ACCEPTANCE CRITERIA NOT MET"
    else
        REVIEWER_VERDICT="unknown"
        log_warning "Reviewer did not clearly state acceptance criteria verdict"
    fi

    # Save AI learnings if present
    if echo "$REVIEWER_OUTPUT" | grep -q "## AI LEARNINGS"; then
        log_info "Saving AI learnings for future sessions..."
        local learnings_content
        learnings_content=$(echo "$REVIEWER_OUTPUT" | sed -n '/## AI LEARNINGS/,/^## /p' | head -n -1)
        save_ai_learning "$learnings_content"
        log_success "AI learnings saved to $AI_LEARNING_FILE"
    fi

    log_info "Verifying tests still pass after review..."
    if run_tests; then
        log_success "Final review complete - all tests still pass"
        git add -A
        git commit -m "REVIEW: Final polish and review" --no-verify 2>/dev/null || true
    else
        log_error "Reviewer broke tests! Reverting..."
        git checkout HEAD -- "$SRC_DIR/" "$TEST_DIR/"
        log_warning "Reviewer changes reverted - tests must pass"
    fi

    lock_all
}

#---------------------------------------------------------------------------
# Main Loop
#---------------------------------------------------------------------------

# Show usage help
show_usage() {
    echo "Usage: ./tdd-tcr-refactor-loop \"Feature requirements\""
    echo "       ./tdd-tcr-refactor-loop --bead <bead-id>"
    echo "       ./tdd-tcr-refactor-loop -b <bead-id>"
    echo "       ./tdd-tcr-refactor-loop --all"
    echo "       ./tdd-tcr-refactor-loop -a"
    echo ""
    echo "Examples:"
    echo "  ./tdd-tcr-refactor-loop \"Add a function to validate email addresses\""
    echo "  ./tdd-tcr-refactor-loop --bead factory-gleam-00s"
    echo "  ./tdd-tcr-refactor-loop --all    # Process ALL open beads by priority"
    echo ""
    echo "This script enforces full Red-Green-Refactor TDD:"
    echo "  - RED:     Auditor writes failing test"
    echo "  - GREEN:   Implementer makes it pass (TCR enforced)"
    echo "  - REFACTOR: Architect improves design every $REFACTOR_INTERVAL cycles"
    echo "  - REVIEW:  Final polish at the end"
    echo ""
    echo "Bead mode automatically:"
    echo "  - Updates bead status to 'in_progress' when starting"
    echo "  - Updates bead status to 'closed' on success"
    echo "  - Updates bead status to 'failed' on failure"
    echo ""
    echo "Tooling integration (auto-detected):"
    echo "  - bv: Graph-aware triage (PageRank, blockers, critical path)"
    echo "  - bd: Bead updates and status management"
    echo "  - codanna: Semantic code search (if initialized)"
    echo "  - Falls back to direct .beads/*.jsonl manipulation"
    echo ""
    echo "Configuration:"
    echo "  - PAUSE_BETWEEN_BEADS=${PAUSE_BETWEEN_BEADS}s (in --all mode)"
    echo "  - REFACTOR_INTERVAL=${REFACTOR_INTERVAL} (architect runs every N green cycles)"
    echo "  - MAX_ITERATIONS=${MAX_ITERATIONS} (max TDD cycles per bead)"
    exit 1
}

# Show all-beads summary banner
show_all_beads_banner() {
    local total_beads="$1"

    clear
    echo ""
    echo -e "${MAGENTA}"
    echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘         â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•  â•‘'
    echo '  â•‘     â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•   â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘              Processing ALL Open Beads by Priority                 â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
    echo ""
    echo -e "  ${CYAN}Total open beads:${NC} ${BOLD}$total_beads${NC}"
    echo -e "  ${CYAN}Processing order:${NC} P0 (Critical) â†’ P1 (High) â†’ P2 (Medium) â†’ P3 (Low)"
    echo ""
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""
}

# Show final summary of all beads processed
show_all_beads_summary() {
    echo ""
    echo -e "${CYAN}"
    echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â•‘'
    echo '  â•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•‘'
    echo '  â•‘     â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—  â•šâ–ˆâ–ˆâ•”â•  â•‘'
    echo '  â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•‘'
    echo '  â•‘     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
    echo ""
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${BOLD}ğŸ“Š ALL BEADS PROCESSING COMPLETE${NC}"
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    echo -e "  ${GREEN}âœ“ COMPLETED (${#COMPLETED_BEADS[@]}):${NC}"
    if [ ${#COMPLETED_BEADS[@]} -gt 0 ]; then
        for bead in "${COMPLETED_BEADS[@]}"; do
            echo -e "    ${GREEN}â€¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""

    echo -e "  ${RED}âœ— FAILED (${#FAILED_BEADS[@]}):${NC}"
    if [ ${#FAILED_BEADS[@]} -gt 0 ]; then
        for bead in "${FAILED_BEADS[@]}"; do
            echo -e "    ${RED}â€¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""

    echo -e "  ${YELLOW}â—‹ SKIPPED (${#SKIPPED_BEADS[@]}):${NC}"
    if [ ${#SKIPPED_BEADS[@]} -gt 0 ]; then
        for bead in "${SKIPPED_BEADS[@]}"; do
            echo -e "    ${YELLOW}â€¢${NC} $bead"
        done
    else
        echo -e "    ${DIM}(none)${NC}"
    fi
    echo ""
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
}

# Process a single bead - returns 0 on success, 1 on failure
process_single_bead() {
    # Mark bead as in_progress when starting
    log_info "Marking bead '$CURRENT_BEAD_ID' as in_progress..."
    update_bead_status "$CURRENT_BEAD_ID" "in_progress"

    # Fancy startup banner
    clear
    echo ""
    echo -e "${CYAN}"
    echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—            â•‘'
    echo '  â•‘   â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—           â•‘'
    echo '  â•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•           â•‘'
    echo '  â•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—           â•‘'
    echo '  â•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘      â•šâ•â•   â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•       â•šâ•â•    â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•           â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â•‘'
    echo '  â•‘          â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•        â•‘'
    echo '  â•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘    â•šâ•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘        â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘          â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘           â•‘'
    echo '  â•‘          â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•   â•šâ•â•           â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•‘       Adversarial AI-Driven Test-Driven Development               â•‘'
    echo '  â•‘       with TCR Discipline and Architectural Oversight             â•‘'
    echo '  â•‘                                                                    â•‘'
    echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    echo -e "${NC}"
    echo ""

    # Config summary in a nice box
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${BOLD}Configuration${NC}"
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${CYAN}Language:${NC}        $PROJECT_LANG"
    echo -e "  ${CYAN}Test Command:${NC}    $TEST_CMD"
    echo -e "  ${CYAN}Source:${NC}          $REQUIREMENTS_SOURCE"
    echo -e "  ${CYAN}Max Iterations:${NC}  $MAX_ITERATIONS"
    if [ "$BEAD_MODE" = true ]; then
        echo -e "  ${MAGENTA}Bead ID:${NC}         $CURRENT_BEAD_ID"
        echo -e "  ${MAGENTA}Bead Title:${NC}      $BEAD_TITLE"
        local priority=$(bead_field "$BEAD_JSON" "priority")
        echo -e "  ${MAGENTA}Priority:${NC}        P$priority"
    fi
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    # Disciplines
    echo -e "  ${RED}â—${NC} ${BOLD}RED${NC}       â†’ ${YELLOW}ğŸ” Auditor${NC} writes failing test"
    echo -e "  ${GREEN}â—${NC} ${BOLD}GREEN${NC}     â†’ ${GREEN}ğŸ”§ Implementer${NC} makes it pass (TCR enforced)"
    echo -e "  ${WHITE}â—${NC} ${BOLD}REFACTOR${NC}  â†’ ${WHITE}ğŸ›ï¸  Architect${NC} cleans up every $REFACTOR_INTERVAL cycles"
    echo -e "  ${MAGENTA}â—${NC} ${BOLD}REVIEW${NC}    â†’ ${MAGENTA}ğŸ“‹ Reviewer${NC} final polish"
    echo ""

    # TCR reminder
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo -e "  ${MAGENTA}âŸ³ TCR:${NC} ${BOLD}Test && Commit || Revert${NC} - No broken code survives"
    echo -e "  ${CYAN}ğŸ“¡ Context:${NC} Reasoning flows between agents"
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    # Requirements in a box
    draw_box "REQUIREMENTS" "${YELLOW}"
    echo "$REQUIREMENTS" | while IFS= read -r line; do
        echo -e "  ${DIM}â”‚${NC} $line"
    done
    echo -e "${DIM}$(draw_line 'â”€')${NC}"
    echo ""

    # Initialize AI learning and history systems
    log_info "Initializing AI learning system..."
    init_ai_learning

    # Initialize history file for context passing between agents
    log_info "Initializing session history for context passing..."
    init_history
    append_history "SESSION START" "0" "Requirements: $REQUIREMENTS"

    log_info "Ensuring clean git state..."
    git add -A
    git commit -m "PRE-TDD-TCR-REFACTOR: Savepoint before loop" --no-verify 2>/dev/null || true

    lock_all

    local iteration=1
    local last_impl_result=""
    local impls_since_refactor=0

    while true; do
        log_phase "TDD-TCR-REFACTOR ITERATION $iteration"

        # Phase 1: Auditor writes test (RED)
        if ! run_auditor "$iteration" "$last_impl_result"; then
            echo ""
            echo -e "${GREEN}"
            echo '  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'
            echo '  â•‘                                                               â•‘'
            echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘'
            echo '  â•‘   â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•  â•‘'
            echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘'
            echo '  â•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘  â•‘'
            echo '  â•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•‘'
            echo '  â•‘   â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•  â•‘'
            echo '  â•‘                                                               â•‘'
            echo '  â•‘         ALL REQUIREMENTS IMPLEMENTED AND TESTED               â•‘'
            echo '  â•‘                                                               â•‘'
            echo '  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
            echo -e "${NC}"
            echo ""

            # Final stats box
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo -e "  ${BOLD}ğŸ“Š FINAL STATISTICS${NC}"
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo -e "  ${GREEN}âœ“${NC} TCR Commits:         ${GREEN}${BOLD}$TCR_COMMITS${NC}"
            echo -e "  ${RED}âœ—${NC} TCR Reverts:         ${RED}${BOLD}$TCR_REVERTS${NC}"
            echo -e "  ${WHITE}ğŸ›ï¸${NC} Architect Refactors: ${WHITE}${BOLD}$REFACTOR_COUNT${NC}"
            echo -e "  ${YELLOW}ğŸ”§${NC} Beads Created:       ${YELLOW}${BOLD}$BEADS_CREATED_BY_ARCHITECT${NC}"
            echo -e "  ${CYAN}ğŸ“${NC} Total Iterations:    ${CYAN}${BOLD}$iteration${NC}"
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo ""

            # Final architect pass before review
            if [ $impls_since_refactor -gt 0 ]; then
                run_architect "$iteration"
            fi

            # Final review
            run_reviewer

            # Mark bead based on reviewer verdict
            if [ "$BEAD_MODE" = true ]; then
                if [ "$REVIEWER_VERDICT" = "passed" ]; then
                    log_success "Marking bead '$CURRENT_BEAD_ID' as closed (acceptance criteria verified)!"
                    local close_msg="Completed via TDD-TCR-REFACTOR loop. Acceptance criteria verified by reviewer. Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS, Refactors: $REFACTOR_COUNT"
                    update_bead_status "$CURRENT_BEAD_ID" "closed" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                elif [ "$REVIEWER_VERDICT" = "failed" ]; then
                    log_error "Marking bead '$CURRENT_BEAD_ID' as failed (acceptance criteria NOT met)"
                    update_bead_status "$CURRENT_BEAD_ID" "failed" "Reviewer determined acceptance criteria were NOT met. Commits: $TCR_COMMITS"
                    FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                else
                    # Unknown verdict - be conservative, mark as needing review
                    log_warning "Marking bead '$CURRENT_BEAD_ID' as needs_review (verdict unclear)"
                    local close_msg="Completed via TDD-TCR-REFACTOR loop but acceptance criteria verdict unclear. Manual review needed. Commits: $TCR_COMMITS"
                    update_bead_status "$CURRENT_BEAD_ID" "needs_review" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE (needs_review)")
                fi
            fi

            unlock_all
            return 0  # Success
        fi

        git add -A
        git commit -m "TEST(tcr-$iteration): New test from auditor" --no-verify 2>/dev/null || true

        log_info "Verifying test is RED (failing)..."

        if run_tests; then
            log_warning "Tests already pass - auditor should write a NEW failing test"
            last_impl_result="All tests passed. Write a new failing test for uncovered requirements."
            iteration=$((iteration + 1))
            continue
        fi

        log_success "Test is RED - proceeding to implementation"

        # Phase 2: Implementer makes it pass (GREEN with TCR)
        if run_implementer "$LAST_TEST_OUTPUT" "$iteration"; then
            last_impl_result="Tests passed and committed. Ready for next test."
            impls_since_refactor=$((impls_since_refactor + 1))

            # Phase 3: Architect refactor check (REFACTOR)
            if [ $impls_since_refactor -ge $REFACTOR_INTERVAL ]; then
                run_architect "$iteration"
                impls_since_refactor=0
            fi
        else
            last_impl_result="Implementation failed after $MAX_IMPL_ATTEMPTS attempts (all reverted). Test may be too ambitious - consider smaller steps."
            log_warning "Continuing despite implementation failure..."
        fi

        iteration=$((iteration + 1))

        if [ $iteration -gt $MAX_ITERATIONS ]; then
            log_phase "MAX ITERATIONS REACHED ($MAX_ITERATIONS)"

            # Final architect pass
            if [ $impls_since_refactor -gt 0 ]; then
                run_architect "$iteration"
            fi

            echo ""
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${GREEN}  FINAL STATISTICS${NC}"
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "  TCR Commits:         ${GREEN}$TCR_COMMITS${NC}"
            echo -e "  TCR Reverts:         ${RED}$TCR_REVERTS${NC}"
            echo -e "  Architect Refactors: ${WHITE}$REFACTOR_COUNT${NC}"
            echo -e "  Beads Created:       ${YELLOW}$BEADS_CREATED_BY_ARCHITECT${NC}"
            echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""

            # Mark bead as closed (max iterations is still a completion, maybe partial)
            if [ "$BEAD_MODE" = true ]; then
                if [ $TCR_COMMITS -gt 0 ]; then
                    log_success "Marking bead '$CURRENT_BEAD_ID' as closed (max iterations reached)"
                    local close_msg="Partial completion via TDD-TCR-REFACTOR loop (max $MAX_ITERATIONS iterations). Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS"
                    update_bead_status "$CURRENT_BEAD_ID" "closed" "$close_msg"
                    COMPLETED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE (partial)")
                else
                    log_error "Marking bead '$CURRENT_BEAD_ID' as failed (no successful commits)"
                    update_bead_status "$CURRENT_BEAD_ID" "failed" "No successful commits after $MAX_ITERATIONS iterations"
                    FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
                fi
            fi

            unlock_all
            return 0  # Finished (even if partial)
        fi

        log_info "Automatically continuing to iteration $iteration..."
    done
}

#---------------------------------------------------------------------------
# Main Entry Point
#---------------------------------------------------------------------------

main() {
    check_dependencies

    # Handle --all mode: process all open beads
    if [ "$ALL_BEADS_MODE" = true ]; then
        local bead_ids
        bead_ids=$(get_all_open_beads)
        local total_beads=$(echo "$bead_ids" | grep -c . || echo 0)

        if [ "$total_beads" -eq 0 ]; then
            echo "No open beads found in $BEADS_DIR/"
            exit 0
        fi

        show_all_beads_banner "$total_beads"
        show_bv_triage

        local bead_num=0
        # Use fd 3 to avoid stdin consumption by claude/other commands inside the loop
        while IFS= read -r bead_id <&3; do
            [ -z "$bead_id" ] && continue
            bead_num=$((bead_num + 1))

            echo ""
            echo -e "${MAGENTA}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
            echo -e "${MAGENTA}â•‘  BEAD ${bead_num}/${total_beads}: ${bead_id}${NC}"
            echo -e "${MAGENTA}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo ""

            # Setup the bead
            if ! setup_bead "$bead_id"; then
                local setup_result=$?
                if [ $setup_result -eq 2 ]; then
                    # Skipped (not open)
                    SKIPPED_BEADS+=("$bead_id: not open")
                else
                    # Error finding bead
                    FAILED_BEADS+=("$bead_id: not found")
                fi
                continue
            fi

            # Process the bead
            if process_single_bead; then
                log_success "Bead '$CURRENT_BEAD_ID' completed!"
            else
                log_error "Bead '$CURRENT_BEAD_ID' failed!"
                FAILED_BEADS+=("$CURRENT_BEAD_ID: $BEAD_TITLE")
            fi

            echo ""
            echo -e "${DIM}$(draw_line 'â”€')${NC}"
            echo -e "  ${CYAN}Progress:${NC} $bead_num / $total_beads beads processed"
            echo -e "${DIM}$(draw_line 'â”€')${NC}"

            # Pause between beads (except after the last one)
            if [ $bead_num -lt $total_beads ] && [ $PAUSE_BETWEEN_BEADS -gt 0 ]; then
                log_info "Pausing ${PAUSE_BETWEEN_BEADS}s before next bead..."
                sleep $PAUSE_BETWEEN_BEADS
            fi

        done 3<<< "$bead_ids"

        show_all_beads_summary
        exit 0
    fi

    # Handle single bead or requirements mode
    if [ -z "$REQUIREMENTS" ] && [ "$BEAD_MODE" = false ]; then
        show_usage
    fi

    # Single bead or requirements mode
    if [ "$BEAD_MODE" = true ] && [ -n "$CURRENT_BEAD_ID" ]; then
        process_single_bead
        exit $?
    fi

    # Plain requirements mode (original behavior)
    process_single_bead
    exit $?
}

cleanup() {
    local exit_code=$?
    log_info "Cleaning up locks..."
    chmod -R u+w "$SRC_DIR/" 2>/dev/null || true
    chmod -R u+w "$TEST_DIR/" 2>/dev/null || true

    # If bead mode and exiting with error (interrupted or failed), mark bead as failed
    if [ "$BEAD_MODE" = true ] && [ $exit_code -ne 0 ]; then
        log_error "Marking bead '$CURRENT_BEAD_ID' as failed (exit code: $exit_code)"
        update_bead_status "$CURRENT_BEAD_ID" "failed" "Loop terminated with exit code $exit_code. Commits: $TCR_COMMITS, Reverts: $TCR_REVERTS"
    fi

    # Keep history file for debugging, but could add: rm -f "$HISTORY_FILE"
}

trap cleanup EXIT

main
