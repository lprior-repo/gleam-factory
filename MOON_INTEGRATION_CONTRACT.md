# Factory + Moon.dev Integration Contract

**Document Purpose**: Specify how Factory integrates with moon.dev as a task execution layer

**Key Principle**: Factory calls moon (not vice versa). Factory is the orchestrator, moon is the executor.

**Status**: Design phase (ready for implementation)

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Task Contract: Factory → Moon](#task-contract-factory--moon)
3. [Configuration Files](#configuration-files)
4. [Pipeline Stages as Moon Tasks](#pipeline-stages-as-moon-tasks)
5. [Feature Flags & Rollout Integration](#feature-flags--rollout-integration)
6. [Monitoring Integration](#monitoring-integration)
7. [Example Workflow](#example-workflow)

---

## Architecture Overview

### Current Model (v1)
```
Factory runs stages directly
└─ No scheduling awareness
└─ No cross-project visibility
└─ Hard to integrate with CI/CD
```

### New Model (v2 with moon)
```
┌─────────────────────────┐
│   Factory Orchestrator  │
│   (Your tool)           │
│                         │
│ - Create workspaces     │
│ - Manage contracts      │
│ - Call moon tasks       │
│ - Aggregate results     │
│ - Control feature flags │
└──────────┬──────────────┘
           │
           │ moon run factory:stage-implement
           │ moon run factory:stage-unit-test
           │ moon run factory:coverage
           │ etc.
           ▼
┌─────────────────────────┐
│   Moon Repository       │
│   (CI/CD Orchestrator)  │
│                         │
│ - Dependency graph      │
│ - Task caching          │
│ - Parallel execution    │
│ - CI/CD integration     │
│ - Cross-repo awareness  │
└─────────────────────────┘
```

### Why Moon?

1. **Scheduling**: Moon understands dependencies between tasks
2. **Caching**: Tasks that haven't changed don't re-run
3. **CI/CD Native**: Integrates with GitHub Actions, etc.
4. **Observability**: Built-in logging and tracing
5. **Cross-Project**: Can orchestrate multiple workspaces
6. **Language Agnostic**: Works with any build system

---

## Task Contract: Factory → Moon

### What Factory Provides to Moon

```yaml
# When factory creates a workspace:
factory new batch-upload --from bd-52.1

# Factory generates:
# .moon/tasks/factory.yml

factory:
  stages:
    implement:
      command: "factory stage bd-52.1 implement"
      description: "Check if code compiles"
      inputs:
        - src/**/*.gleam
        - gleam.toml
      outputs:
        - .factory/bd-52.1/implement.json
      retries: 5

    unit-test:
      command: "factory stage bd-52.1 unit-test"
      description: "Run all unit tests"
      inputs:
        - src/**/*.gleam
        - test/**/*.gleam
      outputs:
        - .factory/bd-52.1/unit-test.json
      retries: 3
      deps:
        - factory:implement  # unit-test depends on implement passing

    coverage:
      command: "factory stage bd-52.1 coverage"
      description: "Verify 80%+ code coverage"
      inputs:
        - src/**/*.gleam
        - test/**/*.gleam
      outputs:
        - .factory/bd-52.1/coverage.json
      retries: 5
      deps:
        - factory:unit-test

    # ... 7 more stages ...

    accept:
      command: "factory stage bd-52.1 accept"
      description: "Mark as ready for merge"
      inputs:
        - .factory/bd-52.1/**/*.json  # All previous stage outputs
      outputs:
        - .factory/bd-52.1/accept.json
      retries: 1
      deps:
        - factory:security  # Last stage before accept
```

### What Moon Provides Back to Factory

Moon executes tasks and provides:

```json
{
  "task": "factory:implement",
  "status": "passed",
  "exit_code": 0,
  "duration_ms": 2340,
  "outputs": {
    "file": ".factory/bd-52.1/implement.json"
  },
  "metadata": {
    "cached": false,
    "ran_at": "2025-01-15T14:30:00Z"
  }
}
```

Factory reads this and:
1. Updates `.factory/bd-52.1/implement.json` with results
2. Decides whether to continue to next stage
3. Aggregates metrics across all stages
4. Generates final deployment decision

---

## Configuration Files

### 1. .moon/tasks/factory.yml

Generated per workspace by factory:

```yaml
# .moon/tasks/factory.yml
# Auto-generated by: factory new batch-upload --from bd-52.1

factory:
  language: gleam
  project: batch-upload
  task_id: bd-52.1

  # All 10 stages as moon tasks
  stages:
    tdd-setup:
      command: "factory stage bd-52.1 tdd-setup"
      description: "Tests exist and fail (RED)"
      inputs: ["test/**/*.gleam"]
      outputs: [".factory/bd-52.1/tdd-setup.json"]
      retries: 3
      tcr: false

    implement:
      command: "factory stage bd-52.1 implement"
      description: "Code compiles"
      inputs: ["src/**/*.gleam", "gleam.toml"]
      outputs: [".factory/bd-52.1/implement.json"]
      retries: 5
      tcr: true
      deps: ["factory:tdd-setup"]

    unit-test:
      command: "factory stage bd-52.1 unit-test"
      description: "All unit tests pass"
      inputs: ["src/**/*.gleam", "test/**/*.gleam"]
      outputs: [".factory/bd-52.1/unit-test.json"]
      retries: 3
      tcr: true
      deps: ["factory:implement"]

    coverage:
      command: "factory stage bd-52.1 coverage"
      description: ">= 80% code coverage"
      inputs: ["src/**/*.gleam", "test/**/*.gleam"]
      outputs: [".factory/bd-52.1/coverage.json"]
      retries: 5
      tcr: true
      deps: ["factory:unit-test"]

    lint:
      command: "factory stage bd-52.1 lint"
      description: "Format clean"
      inputs: ["src/**/*.gleam"]
      outputs: [".factory/bd-52.1/lint.json"]
      retries: 3
      tcr: true
      deps: ["factory:coverage"]

    static:
      command: "factory stage bd-52.1 static"
      description: "Type check passes"
      inputs: ["src/**/*.gleam"]
      outputs: [".factory/bd-52.1/static.json"]
      retries: 3
      tcr: true
      deps: ["factory:lint"]

    integration:
      command: "factory stage bd-52.1 integration"
      description: "Integration tests pass"
      inputs: ["src/**/*.gleam", "test/**/*.gleam"]
      outputs: [".factory/bd-52.1/integration.json"]
      retries: 3
      tcr: true
      deps: ["factory:static"]

    security:
      command: "factory stage bd-52.1 security"
      description: "No high/critical vulnerabilities"
      inputs: ["src/**/*.gleam", "Cargo.lock"]
      outputs: [".factory/bd-52.1/security.json"]
      retries: 2
      tcr: true
      deps: ["factory:integration"]

    review:
      command: "factory stage bd-52.1 review"
      description: "Code review passes"
      inputs: [".factory/bd-52.1/**/*.json"]
      outputs: [".factory/bd-52.1/review.json"]
      retries: 3
      tcr: true
      deps: ["factory:security"]

    accept:
      command: "factory stage bd-52.1 accept"
      description: "Merge-ready (final gate)"
      inputs: [".factory/bd-52.1/**/*.json"]
      outputs: [".factory/bd-52.1/accept.json"]
      retries: 1
      tcr: false
      deps: ["factory:review"]
```

### 2. .factory/bd-52.1/contract.yaml

Human-written contract:

```yaml
# .factory/bd-52.1/contract.yaml
# Written by you, enforced by factory

contract:
  task_id: bd-52.1
  title: "Implement batch upload HTTP handler"
  from_issue: bd-52
  created_date: 2025-01-15

  # What this task does
  scope:
    description: |
      Implement POST /api/videos/batch endpoint that:
      - Accepts JSON array of URLs
      - Returns batch_id immediately (async)
      - Rate limits: max 100 URLs/minute per user
      - Validates URLs asynchronously

  # Success criteria (from intent spec)
  success_criteria:
    - "Handler accepts array of URLs"
    - "Returns batch_id immediately"
    - "No sync validation (must be async)"
    - "Rate limit enforced"

  # Acceptance criteria (testable)
  acceptance_criteria:
    - "POST /api/videos/batch endpoint exists"
    - "Returns 201 Created with batch_id"
    - "Validation happens asynchronously"
    - "Rate limit triggered at >100 URLs"

  # Required tests (from intent spec)
  test_requirements:
    - test_batch_endpoint_accepts_urls
    - test_batch_id_returned_immediately
    - test_async_validation_occurs
    - test_rate_limit_enforced_at_100
    - test_concurrent_requests_handled

  # Code boundaries
  boundaries:
    allowed_files:
      - src/web/handlers.gleam
      - src/web/handlers_test.gleam
      - test/fixtures/batch_requests.json

    forbidden_files:
      - src/core/rate_limiter.gleam  # That's bd-52.2
      - src/core/validator.gleam     # That's bd-52.3
      - src/infra/db.gleam           # That's bd-52.4

  # Dependencies
  dependencies:
    must_complete_before:
      - bd-52.1-a: "Handler setup" (if decomposed further)
    must_complete_after: []  # This can start immediately

  # Moon task targets
  moon_tasks:
    - factory:implement
    - factory:unit-test
    - factory:coverage
    - factory:lint
    - factory:static
    - factory:integration
    - factory:security
    - factory:review
    - factory:accept
```

### 3. .factory/gleam.yaml

Language-specific config:

```yaml
# .factory/gleam.yaml
# Auto-generated on language detection

language: gleam
version: 0.44

build_system:
  manifest: gleam.toml
  package_manager: gleam

stages:
  implement:
    command: "gleam check && gleam build"
    expected_output:
      - "✓ Compiling"
    success_means: "exit_code == 0"
    failure_patterns:
      - "Error:"
      - "Compilation failed"

  unit_test:
    command: "gleam test"
    expected_output:
      - "test result: ok"
    success_means: "exit_code == 0"
    failure_patterns:
      - "test result: fail"

  coverage:
    command: "gleam test --coverage"
    parse_output: "JSON"
    success_means: "coverage_percent >= 80"

  lint:
    command: "gleam format --check"
    expected_output:
      - "All formatted"
    success_means: "exit_code == 0"

  static:
    command: "gleam check"
    expected_output:
      - "0 errors"
    success_means: "exit_code == 0"

  integration:
    command: "gleam test --tag integration"
    success_means: "exit_code == 0"

  security:
    command: "./scripts/security-scan.sh"
    success_means: "exit_code == 0 AND contains 'No vulns'"

  review:
    command: "echo 'Code review required' && exit 0"
    note: "Human review, not automated"

  accept:
    command: "echo 'Ready to merge' && exit 0"
    note: "Final acceptance gate"
```

---

## Pipeline Stages as Moon Tasks

### How Factory Calls Moon

```bash
# User runs:
factory run batch-upload

# Factory does:
1. Validate contract
2. Create .moon/tasks/factory.yml
3. Call: moon run factory:tdd-setup
4. Check result
5. If pass: moon run factory:implement
6. If pass: moon run factory:unit-test
7. ... and so on for all 10 stages

# Each stage is a moon task with:
# - Explicit inputs (what changed)
# - Explicit outputs (what result)
# - Dependencies (what must pass first)
# - Retries (how many attempts)
# - Caching (don't re-run if inputs unchanged)
```

### Moon Task Structure

```yaml
implement:
  command: "factory stage bd-52.1 implement"

  # Moon knows what files matter
  inputs:
    - src/**/*.gleam      # Source code
    - gleam.toml          # Manifest
    - .factory/gleam.yaml # Language config

  # Moon caches results in these files
  outputs:
    - .factory/bd-52.1/implement.json

  # How many times to retry
  retries: 5

  # What tasks must complete first
  deps:
    - factory:tdd-setup  # Implement depends on tdd-setup

  # TCR enabled? (determines revert behavior)
  tcr: true

  # Metadata
  description: "Check if code compiles"
  tags:
    - gleam
    - stage-2
    - tcr-enabled
```

### Output Files for Tracking

Each stage produces a JSON output:

```json
// .factory/bd-52.1/implement.json
{
  "task": "factory:implement",
  "stage": 2,
  "stage_name": "implement",
  "status": "passed",
  "exit_code": 0,
  "duration_ms": 2340,
  "timestamp": "2025-01-15T14:30:00Z",

  "command": "gleam check && gleam build",
  "command_output": "✓ Compiling gleam_stdlib 0.44.0\n✓ Compiling factory_gleam",

  "contract_satisfied": true,
  "tcr_enabled": true,
  "tcr_triggered": false,

  "metrics": {
    "lines_changed": 47,
    "files_changed": 2,
    "complexity_delta": 2
  }
}
```

---

## Feature Flags & Rollout Integration

### How Moon Tasks Handle Feature Flags

```yaml
# .moon/tasks/factory.yml

deploy:
  # Not a traditional moon task, but orchestration point

  stages_all_passed:
    condition: "factory:accept status == passed"

    then_do:
      # Don't deploy directly
      # Instead: prepare for gradual rollout

      - action: enable_feature_flag
        flag_name: batch_upload
        percentage: 1  # Start at 1%
        duration: 5_minutes

      - action: start_monitoring
        metrics:
          - error_rate
          - latency_p99
          - rate_limit_violations

      - action: create_decision_point
        after: 5_minutes
        ask: "Expand to 10% users?"
        options:
          - expand_to_10_percent
          - rollback
          - investigate
```

### Integration with CI/CD

```yaml
# .github/workflows/factory-pipeline.yml

name: Factory Pipeline

on: [pull_request]

jobs:
  factory-stages:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run Factory through Moon
        run: |
          # Run the full pipeline via moon
          moon run factory:tdd-setup
          moon run factory:implement
          moon run factory:unit-test
          moon run factory:coverage
          moon run factory:lint
          moon run factory:static
          moon run factory:integration
          moon run factory:security
          # Stop here for PR review
          # Don't auto-approve review/accept stages

      - name: Report Results
        if: always()
        run: |
          # Aggregate all .factory/bd-*/stage.json files
          factory report --format=github-actions
          # Output as GitHub check

      - name: Feature Flag Decision
        if: all_stages_passed
        run: |
          # Show deployment options
          factory deploy --show-options batch-upload
          # User must manually approve via GitHub UI
          # Then: factory deploy --approve --flag batch-upload --percentage 1
```

---

## Monitoring Integration

### Intent Rule Validation in Moon

Moon can run additional checks based on intent spec:

```yaml
# Additional moon tasks for production validation

factory:
  # ... 10 stages above ...

  # Post-deployment tasks
  monitor-intent-rules:
    command: "factory monitor --check-rules batch_upload"
    inputs:
      - .factory/batch_upload/rules.json
    outputs:
      - .factory/batch_upload/monitoring.json
    schedule: every_5_minutes

  check-error-rate:
    command: "factory check --metric error_rate --threshold 2%"
    inputs:
      - .factory/batch_upload/baseline.json
    outputs:
      - .factory/batch_upload/error-check.json
    schedule: every_5_minutes
    auto_rollback_if: "error_rate > baseline + 100%"

  check-rate-limit-violations:
    command: "factory check --metric rate_limit_violations"
    inputs:
      - .factory/batch_upload/baseline.json
    outputs:
      - .factory/batch_upload/rate-limit-check.json
    schedule: every_5_minutes
    auto_rollback_if: "violations > baseline + 50%"
```

---

## Example Workflow

### Step 1: Create Workspace

```bash
lewis@machine:~/src/factory-gleam$ factory new batch-upload --from bd-52.1

✓ Created workspace: batch-upload
✓ Detected language: gleam
✓ Generated: .moon/tasks/factory.yml
✓ Loaded contract: .factory/bd-52.1/contract.yaml
✓ Pre-commit hook installed
✓ Boundary enforcement: src/web/handlers.gleam only
✓ Ready to work

Next:
  factory run batch-upload        # Run full pipeline
  factory stage batch-upload lint # Run single stage
```

### Step 2: Work and Commit

```bash
lewis@machine:~/src/factory-gleam$ vim src/web/handlers.gleam
# ... implement handler ...

lewis@machine:~/src/factory-gleam$ git add src/web/handlers.gleam
lewis@machine:~/src/factory-gleam$ git commit -m "Implement batch upload handler"

✓ Pre-commit hook: checking boundaries...
✓ Files allowed: src/web/handlers.gleam ✓
✓ Commit accepted
```

### Step 3: Run Pipeline via Moon

```bash
lewis@machine:~/src/factory-gleam$ factory run batch-upload

Running: bd-52.1 (Implement batch upload HTTP handler)

[ 1/10] tdd-setup
  ✓ Tests exist and fail (RED)
  Command: gleam test
  Exit code: 1 (tests failing as expected)

[ 2/10] implement
  moon run factory:implement
  ✓ Code compiles
  Duration: 2.3s
  Exit code: 0
  Output saved to: .factory/bd-52.1/implement.json

[ 3/10] unit-test
  moon run factory:unit-test
  ✓ All unit tests pass
  Duration: 1.8s
  Tests run: 5/5 passing
  Exit code: 0
  Output saved to: .factory/bd-52.1/unit-test.json

[ 4/10] coverage
  moon run factory:coverage
  ✓ 89% coverage (threshold: 80%)
  Duration: 2.1s
  Exit code: 0
  Output saved to: .factory/bd-52.1/coverage.json

[ 5/10] lint
  moon run factory:lint
  ✓ Format clean
  Duration: 0.9s
  Exit code: 0

[ 6/10] static
  moon run factory:static
  ✓ Type check passes
  Duration: 1.2s
  Exit code: 0

[ 7/10] integration
  moon run factory:integration
  ✓ Integration tests pass
  Duration: 2.4s
  Exit code: 0

[ 8/10] security
  moon run factory:security
  ✓ No high/critical vulnerabilities
  Duration: 3.1s
  Exit code: 0

[ 9/10] review
  Code review required (human decision)

  Metrics:
    - Test coverage: 89%
    - Lines changed: 47
    - New dependencies: 0
    - Focus areas: 3 sections

  Your decision: [approve/reject/skip]
  > approve

  ✓ Code review approved

[10/10] accept
  ✓ All gates passed
  Status: READY_FOR_DEPLOYMENT

═══════════════════════════════════════════════════

SUMMARY:
✓ All 10 stages passed
✓ Contract satisfied
✓ Ready for gradual rollout

Your action required:
  factory deploy --approve batch-upload

This will:
  1. Enable feature flag to 1% users
  2. Monitor for 5 minutes
  3. Ask for expansion decision
```

### Step 4: Deploy with Feature Flag

```bash
lewis@machine:~/src/factory-gleam$ factory deploy --approve batch-upload

Preparing deployment:
✓ Feature flag created: batch_upload
✓ Percentage: 1%
✓ Duration: 5 minutes
✓ Monitoring: enabled

Monitoring:
  1% users (canary)
  └─ Error rate: 0.02% (baseline: 0.01%) ✓
  └─ Latency p99: 45ms (baseline: 40ms) ✓
  └─ Rate limit violations: 0 ✓

  After 5 minutes:
  ✓ All metrics normal
  ✓ Ready to expand?

  Options:
    1. factory flag batch-upload --percentage 10
    2. factory flag batch-upload --percentage 0 (rollback)
    3. factory monitor batch-upload --continue (stay at 1%)

Your decision > 1

Expanding to 10%:
✓ Feature flag: 10%
✓ Duration: 30 minutes
✓ Monitoring: continues

After 30 minutes:
✓ Error rate: normal ✓
✓ Latency: normal ✓
✓ User behavior: normal ✓

Ready to deploy 100%? (y/n) > y

Deploying to 100%:
✓ Feature flag: 100%
✓ Monitoring: ongoing
✓ Status: LIVE

Next:
  factory monitor batch-upload --ongoing  # Keep watching
```

### Step 5: Incident Learning (if needed)

```bash
# If monitoring detected incident:

factory incident report batch-upload

Incident: Rate limiter failed under load
├─ Detection: 14:35 (5 min after deploy)
├─ Impact: 1,200 users
├─ Action: Auto-rollback triggered
│  └─ Feature flag: batch_upload → 0%
│  └─ Duration: < 100ms
│  └─ Users impacted: returned to old behavior
│
├─ Root cause: Race condition in concurrent requests
├─ Fix applied: Add mutex to token bucket
│
├─ Learning:
│  └─ New requirement: "All rate limiter tasks require concurrent load test"
│  └─ Applied to: bd-52.2 (rate limiter implementation)
│  └─ Prevents: This specific bug in future
│
└─ Next: Fix rate limiter, re-run pipeline
```

---

## Benefits of Moon Integration

### For Factory (Orchestrator)
- ✅ Cleaner separation: Factory owns pipeline logic, moon owns execution
- ✅ Better error handling: Moon's structured output
- ✅ Caching: Don't re-run stages if inputs unchanged
- ✅ Dependency resolution: Moon handles complex DAGs
- ✅ Cross-project: Can run tasks across multiple repos

### For Moon (CI/CD)
- ✅ Language-agnostic plugin: Works for any factory task
- ✅ Better observability: Factory pipeline visible in moon tasks
- ✅ Integration with CI/CD: Fits naturally in GitHub Actions, etc.
- ✅ Feature flag support: Moon can orchestrate deployments

### For You (Developer)
- ✅ Familiar tools: Moon is industry standard
- ✅ Better debugging: Moon's logs and caching
- ✅ Faster feedback: Cached tasks don't re-run
- ✅ CI/CD visibility: GitHub Actions integration
- ✅ Team awareness: Other developers see pipeline in moon

---

## Summary

**Factory + Moon Integration:**
1. Factory calls moon (factory is orchestrator)
2. Moon executes stages (moon is executor)
3. Results flow back to factory (factory makes decisions)
4. Feature flags provide rollout control
5. Monitoring validates intent rules
6. Learning loops feed back into contracts

This architecture separates concerns:
- **Factory**: Knows about contracts, boundaries, decisions
- **Moon**: Knows about execution, caching, dependencies
- **Together**: A powerful CI/CD and quality pipeline system

